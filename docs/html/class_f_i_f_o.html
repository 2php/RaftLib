<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>RaftLib: FIFO Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RaftLib
   &#160;<span id="projectnumber">0.3a</span>
   </div>
   <div id="projectbrief">C++ Stream Processing Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_f_i_f_o-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FIFO Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea969385961885a8e70732482d64fead"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#aea969385961885a8e70732482d64fead">FIFO</a> ()</td></tr>
<tr class="separator:aea969385961885a8e70732482d64fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d31a29b91fed5e154f26bf9df4d280"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a44d31a29b91fed5e154f26bf9df4d280">~FIFO</a> ()</td></tr>
<tr class="separator:a44d31a29b91fed5e154f26bf9df4d280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80b8555fc249168560c67cd0a13e574"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ae80b8555fc249168560c67cd0a13e574">size</a> ()=0</td></tr>
<tr class="separator:ae80b8555fc249168560c67cd0a13e574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34aa9afd24e536aad0a9553863b6fe6"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ac34aa9afd24e536aad0a9553863b6fe6">space_avail</a> ()=0</td></tr>
<tr class="separator:ac34aa9afd24e536aad0a9553863b6fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64565d7156f6796ff14c3033387043b1"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a64565d7156f6796ff14c3033387043b1">capacity</a> ()=0</td></tr>
<tr class="separator:a64565d7156f6796ff14c3033387043b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad12d67e3611fafae4d6ed862c60b9"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a43ad12d67e3611fafae4d6ed862c60b9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a43ad12d67e3611fafae4d6ed862c60b9">allocate</a> ()</td></tr>
<tr class="separator:a43ad12d67e3611fafae4d6ed862c60b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1becf13fcc3330e6689d3aea756e6"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args, typename std::enable_if&lt; std::is_object&lt; T &gt;::value and notstd::is_fundamental&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ec1becf13fcc3330e6689d3aea756e6"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a9ec1becf13fcc3330e6689d3aea756e6">allocate</a> (Args &amp;&amp;...params)</td></tr>
<tr class="separator:a9ec1becf13fcc3330e6689d3aea756e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37b9a289093791f4bb9e4ef4e4e271a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#af37b9a289093791f4bb9e4ef4e4e271a">deallocate</a> ()=0</td></tr>
<tr class="separator:af37b9a289093791f4bb9e4ef4e4e271a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6fa58bc6b5734c3f7fc288dd58a6e3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8c6fa58bc6b5734c3f7fc288dd58a6e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a8c6fa58bc6b5734c3f7fc288dd58a6e3">allocate_s</a> () -&gt; autorelease&lt; T, allocatetype &gt;</td></tr>
<tr class="separator:a8c6fa58bc6b5734c3f7fc288dd58a6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b93da58a3fd6ecd844827c4fcbd2473"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b93da58a3fd6ecd844827c4fcbd2473"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a8b93da58a3fd6ecd844827c4fcbd2473">allocate_range</a> (const std::size_t n) -&gt; std::vector&lt; std::reference_wrapper&lt; T &gt; &gt;</td></tr>
<tr class="separator:a8b93da58a3fd6ecd844827c4fcbd2473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb564ddace3951ed7754a285b438ba4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a0bb564ddace3951ed7754a285b438ba4">send</a> (const raft::signal=raft::none)=0</td></tr>
<tr class="separator:a0bb564ddace3951ed7754a285b438ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be4de6db251e1a2e6dcc97a5d4a584"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ac0be4de6db251e1a2e6dcc97a5d4a584">send_range</a> (const raft::signal=raft::none)=0</td></tr>
<tr class="separator:ac0be4de6db251e1a2e6dcc97a5d4a584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381974271d6c818473edd23c355f0d36"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a381974271d6c818473edd23c355f0d36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a381974271d6c818473edd23c355f0d36">push</a> (const T &amp;item, const raft::signal signal=raft::none)</td></tr>
<tr class="separator:a381974271d6c818473edd23c355f0d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa848776c8d7b4966a8531b670c429e98"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa848776c8d7b4966a8531b670c429e98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#aa848776c8d7b4966a8531b670c429e98">push</a> (T &amp;&amp;item, const raft::signal signal=raft::none)</td></tr>
<tr class="separator:aa848776c8d7b4966a8531b670c429e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922b94b854cc9e3ee37fbd447982f663"><td class="memTemplParams" colspan="2">template&lt;class iterator_type &gt; </td></tr>
<tr class="memitem:a922b94b854cc9e3ee37fbd447982f663"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a922b94b854cc9e3ee37fbd447982f663">insert</a> (iterator_type begin, iterator_type end, const raft::signal signal=raft::none)</td></tr>
<tr class="separator:a922b94b854cc9e3ee37fbd447982f663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0607b6c931ed1fab618e637af617dd15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0607b6c931ed1fab618e637af617dd15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a0607b6c931ed1fab618e637af617dd15">pop</a> (T &amp;item, raft::signal *signal=nullptr)</td></tr>
<tr class="separator:a0607b6c931ed1fab618e637af617dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23be63e817ff487d32013064e752f02f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a23be63e817ff487d32013064e752f02f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a23be63e817ff487d32013064e752f02f">pop_range</a> (pop_range_t&lt; T &gt; &amp;items, const std::size_t n_items)</td></tr>
<tr class="separator:a23be63e817ff487d32013064e752f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fd3ad9300e6ea9deb88677181c2a3c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a16fd3ad9300e6ea9deb88677181c2a3c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a16fd3ad9300e6ea9deb88677181c2a3c">peek</a> (raft::signal *signal=nullptr)</td></tr>
<tr class="separator:a16fd3ad9300e6ea9deb88677181c2a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eebb934a2d29c17916eb21db85fd39d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4eebb934a2d29c17916eb21db85fd39d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a4eebb934a2d29c17916eb21db85fd39d">peek_range</a> (const std::size_t n) -&gt; autorelease&lt; T, peekrange &gt;</td></tr>
<tr class="separator:a4eebb934a2d29c17916eb21db85fd39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cbb6c4a5b8783af38c6deb1a6f651e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#aa0cbb6c4a5b8783af38c6deb1a6f651e">unpeek</a> ()=0</td></tr>
<tr class="separator:aa0cbb6c4a5b8783af38c6deb1a6f651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58f3828e61026c45f8aacb13160aa81"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab58f3828e61026c45f8aacb13160aa81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ab58f3828e61026c45f8aacb13160aa81">recycle</a> (const T &amp;t, const std::size_t range=1)</td></tr>
<tr class="separator:ab58f3828e61026c45f8aacb13160aa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58f3828e61026c45f8aacb13160aa81"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab58f3828e61026c45f8aacb13160aa81"></a>
template&lt;class T , typename std::enable_if&lt; std::is_object&lt; T &gt;::value and notstd::is_fundamental&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab58f3828e61026c45f8aacb13160aa81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>recycle</b> (const T &amp;t, const std::size_t range=1)</td></tr>
<tr class="separator:ab58f3828e61026c45f8aacb13160aa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa372ba61179c80ce8355aadbdbbad844"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#aa372ba61179c80ce8355aadbdbbad844">get_zero_read_stats</a> (<a class="el" href="union_blocked.html">Blocked</a> &amp;copy)</td></tr>
<tr class="separator:aa372ba61179c80ce8355aadbdbbad844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd419cc4b99bd13f6b018145844bdd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a6dd419cc4b99bd13f6b018145844bdd2">get_zero_write_stats</a> (<a class="el" href="union_blocked.html">Blocked</a> &amp;copy)</td></tr>
<tr class="separator:a6dd419cc4b99bd13f6b018145844bdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27264d14b86811604a54e0d30aa22c33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a27264d14b86811604a54e0d30aa22c33">resize</a> (const std::size_t n_items, const std::size_t align, volatile bool &amp;exit_alloc)=0</td></tr>
<tr class="separator:a27264d14b86811604a54e0d30aa22c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d44784c43a4026508e85982eb3174c7"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a4d44784c43a4026508e85982eb3174c7">get_frac_write_blocked</a> ()=0</td></tr>
<tr class="separator:a4d44784c43a4026508e85982eb3174c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65e8231c0d1a7cdf250f2ce57f3723f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#af65e8231c0d1a7cdf250f2ce57f3723f">invalidate</a> ()=0</td></tr>
<tr class="separator:af65e8231c0d1a7cdf250f2ce57f3723f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bc45169bff5253496dc6bf6f902f89"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a01bc45169bff5253496dc6bf6f902f89">is_invalid</a> ()=0</td></tr>
<tr class="separator:a01bc45169bff5253496dc6bf6f902f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a43169f0969c4858d21ed7f5bc5fc64ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43169f0969c4858d21ed7f5bc5fc64ee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>recyclefunc</b> = std::function&lt; void(void *) &gt;</td></tr>
<tr class="separator:a43169f0969c4858d21ed7f5bc5fc64ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa9c1f679b4e2585047af2c09a2518209"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#aa9c1f679b4e2585047af2c09a2518209">set_src_kernel</a> (<a class="el" href="classraft_1_1kernel.html">raft::kernel</a> *const k)=0</td></tr>
<tr class="separator:aa9c1f679b4e2585047af2c09a2518209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11422695c75c05ad2c60e662553f2667"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a11422695c75c05ad2c60e662553f2667">set_dst_kernel</a> (<a class="el" href="classraft_1_1kernel.html">raft::kernel</a> *const k)=0</td></tr>
<tr class="separator:a11422695c75c05ad2c60e662553f2667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7519af834c969d49f3d9ae7080af9"><td class="memItemLeft" align="right" valign="top">virtual raft::signal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a36a7519af834c969d49f3d9ae7080af9">signal_peek</a> ()=0</td></tr>
<tr class="separator:a36a7519af834c969d49f3d9ae7080af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b606d47361489007490e0e0b4e2aa1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ad6b606d47361489007490e0e0b4e2aa1">signal_pop</a> ()=0</td></tr>
<tr class="separator:ad6b606d47361489007490e0e0b4e2aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e91c74078cd52cdfc6f3609b83c8eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ae7e91c74078cd52cdfc6f3609b83c8eb">inline_signal_send</a> (const raft::signal sig)=0</td></tr>
<tr class="separator:ae7e91c74078cd52cdfc6f3609b83c8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60068cb00b13626e41d4b11099354ae3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a60068cb00b13626e41d4b11099354ae3">local_allocate</a> (void **ptr)=0</td></tr>
<tr class="separator:a60068cb00b13626e41d4b11099354ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acc34ebbad9df32f54ae8c618ffa0c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a4acc34ebbad9df32f54ae8c618ffa0c0">local_allocate_n</a> (void *ptr, const std::size_t n)=0</td></tr>
<tr class="separator:a4acc34ebbad9df32f54ae8c618ffa0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef48ce2cb02e8bd5d381bb65687e6cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a4ef48ce2cb02e8bd5d381bb65687e6cb">local_push</a> (void *ptr, const raft::signal &amp;signal)=0</td></tr>
<tr class="separator:a4ef48ce2cb02e8bd5d381bb65687e6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e42eddd74c0c5ce4a640c0cc022245"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ab3e42eddd74c0c5ce4a640c0cc022245">local_insert</a> (void *ptr_begin, void *ptr_end, const raft::signal &amp;signal, const std::size_t iterator_type)=0</td></tr>
<tr class="separator:ab3e42eddd74c0c5ce4a640c0cc022245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ca430a795bbf0904c041dcdfd836a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#ad7ca430a795bbf0904c041dcdfd836a4">local_pop</a> (void *ptr, raft::signal *signal)=0</td></tr>
<tr class="separator:ad7ca430a795bbf0904c041dcdfd836a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edc6a38e9cb2e13eae8afe0703236d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a6edc6a38e9cb2e13eae8afe0703236d7">local_pop_range</a> (void *ptr_data, std::size_t n_items)=0</td></tr>
<tr class="separator:a6edc6a38e9cb2e13eae8afe0703236d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc960790e2803da85fa24e64c61c38b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#afc960790e2803da85fa24e64c61c38b5">local_peek</a> (void **ptr, raft::signal *signal)=0</td></tr>
<tr class="separator:afc960790e2803da85fa24e64c61c38b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8056adb06fadf2b7aae4d9858795be45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a8056adb06fadf2b7aae4d9858795be45">local_peek_range</a> (void **ptr, void **sig, const std::size_t n_items, std::size_t &amp;curr_pointer_loc)=0</td></tr>
<tr class="separator:a8056adb06fadf2b7aae4d9858795be45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f898343d6c6caf98f5434964d43f627"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#a1f898343d6c6caf98f5434964d43f627">local_recycle</a> (const std::size_t range)=0</td></tr>
<tr class="separator:a1f898343d6c6caf98f5434964d43f627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334a9f0c34d7b03768ed7330ee80ffb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334a9f0c34d7b03768ed7330ee80ffb4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>local_recycle</b> (const std::size_t range, recyclefunc func)=0</td></tr>
<tr class="separator:a334a9f0c34d7b03768ed7330ee80ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aae5808dc2e987bf17ef42196457a654d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_f_o.html#aae5808dc2e987bf17ef42196457a654d">Schedule</a></td></tr>
<tr class="separator:aae5808dc2e987bf17ef42196457a654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fd97b135f77d4b136e8fff9a1c1ae1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64fd97b135f77d4b136e8fff9a1c1ae1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Allocate</b></td></tr>
<tr class="separator:a64fd97b135f77d4b136e8fff9a1c1ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aea969385961885a8e70732482d64fead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FIFO::FIFO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_f_i_f_o.html">FIFO</a> - default constructor for base class for all subsequent ringbuffers.</p>
<p>FIFO.cpp - </p><dl class="section author"><dt>Author</dt><dd>: Jonathan Beard </dd></dl>
<dl class="section version"><dt>Version</dt><dd>: Thu Sep 4 12:59:45 2014</dd></dl>
<p>Copyright 2014 Jonathan Beard</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at:</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>

</div>
</div>
<a class="anchor" id="a44d31a29b91fed5e154f26bf9df4d280"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FIFO::~FIFO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>~FIFO - default destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43ad12d67e3611fafae4d6ed862c60b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; FIFO::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocate - returns a reference to a writeable member at the tail of the <a class="el" href="class_f_i_f_o.html">FIFO</a>. You must have a subsequent call to send in order to release this object to the <a class="el" href="class_f_i_f_o.html">FIFO</a> once it is written. If the user needs to de-allocate the memory without using it, they can call the deallocate function. </p><dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>
<p>call blocks till an element is available </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9ec1becf13fcc3330e6689d3aea756e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args, typename std::enable_if&lt; std::is_object&lt; T &gt;::value and notstd::is_fundamental&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; FIFO::allocate </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>call blocks till an element is available </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 1 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8b93da58a3fd6ecd844827c4fcbd2473"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto FIFO::allocate_range </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; std::vector&lt; std::reference_wrapper&lt; T &gt; &gt;
   </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO, fix allocate_range to double buffer properly if not enough mem available allocate_range - returns a std::vector of references to n items on the queue. If for some reason the capacity of the queue is less than n or some other unspecified error occurs then the number allocated is returned in n_ret. To release items to the queue, use push_range as opposed to the standard push. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- const std::size_t, # items to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt; std::reference_wrapper&lt; T &gt; &gt; </dd></dl>
<p>compiler should optimize this copy, if not then it'll be a copy of referneces not full objects </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a8b93da58a3fd6ecd844827c4fcbd2473_cgraph.svg" width="360" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8c6fa58bc6b5734c3f7fc288dd58a6e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto FIFO::allocate_s </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; autorelease&lt; T, allocatetype &gt;
   </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocate_s - "auto-release" version of allocate, where the action of pushing the memory allocated to the consumer is handled by the returned object exiting the calling stack frame. </p><dl class="section return"><dt>Returns</dt><dd>autorelease&lt; T, allocatetype &gt; </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a8c6fa58bc6b5734c3f7fc288dd58a6e3_cgraph.svg" width="320" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a64565d7156f6796ff14c3033387043b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t FIFO::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>capacity - returns the set maximum capacity of the <a class="el" href="class_f_i_f_o.html">FIFO</a>. </p><dl class="section return"><dt>Returns</dt><dd>std::size_t </dd></dl>

</div>
</div>
<a class="anchor" id="af37b9a289093791f4bb9e4ef4e4e271a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>deallocate - call after allocate if memory allocated is not needed. Will deallocate all memory allocated by a previous allocate call. </p>

</div>
</div>
<a class="anchor" id="a4d44784c43a4026508e85982eb3174c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float FIFO::get_frac_write_blocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_frac_write_blocked - returns the fraction of time that this queue was blocked. This might become a private function accessible only to the dynamic allocator mechanism, but for now its a public function. </p><dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a4d44784c43a4026508e85982eb3174c7_icgraph.svg" width="302" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa372ba61179c80ce8355aadbdbbad844"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::get_zero_read_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_blocked.html">Blocked</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_zero_read_stats - sets the param variable to the current blocked stats and then sets the current vars to zero. Default version here does nothing, when instrumentation is enabled then the function called actually does something. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>- <a class="el" href="union_blocked.html">Blocked</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<p>default version does nothing at all </p>

</div>
</div>
<a class="anchor" id="a6dd419cc4b99bd13f6b018145844bdd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::get_zero_write_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_blocked.html">Blocked</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get_zero_write_stats - sets the param variable to the current blocked stats and then sets the current vars to zero. Default version here does nothing, when instrumentation is enabled then the function, called actually does something. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>- <a class="el" href="union_blocked.html">Blocked</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<p>default version does nothing at all </p>

</div>
</div>
<a class="anchor" id="ae7e91c74078cd52cdfc6f3609b83c8eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::inline_signal_send </td>
          <td>(</td>
          <td class="paramtype">const raft::signal&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>inline_signal_send - pretty much exactly like it sounds, the implementations of this function must pass a signal inline with the data stream so that this signal is received immediately after the data element sent before it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>- raft::signal, signal to be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a922b94b854cc9e3ee37fbd447982f663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class iterator_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::insert </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const raft::signal&#160;</td>
          <td class="paramname"><em>signal</em> = <code>raft::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>insert - inserts the range from begin to end in the <a class="el" href="class_f_i_f_o.html">FIFO</a>, blocks until space is available. If the range is greater than the space available it'll simply block and add items as space becomes available. There is the implicit assumption that another thread is consuming the data, so eventually there will be room. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>- iterator_type, iterator to begin of range </td></tr>
    <tr><td class="paramname">end</td><td>- iterator_type, iterator to end of range </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal, default raft::none </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a922b94b854cc9e3ee37fbd447982f663_cgraph.svg" width="280" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af65e8231c0d1a7cdf250f2ce57f3723f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::invalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>invalidate - used by producer thread to label this queue as invalid. Could be for many differing reasons, however the bottom line is that once empty, this queue will receive no extra data and the receiver must do something to deal with this type of behavior if more data is requested. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 2 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a01bc45169bff5253496dc6bf6f902f89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool FIFO::is_invalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>is_invalid - called by the consumer thread to check if this queue is in fact valid. This is typically only called if the queue is empty or if the consumer is asking for more data than is currently available. </p><dl class="section return"><dt>Returns</dt><dd>bool - true if invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a60068cb00b13626e41d4b11099354ae3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_allocate </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_allocate - in order to get this whole thing to work with multiple "ports" contained within the same container we have to erase the type and then put it back. To do this the template function gives a void ptr mem address which is given the location to the head of the queue. Once returned the main allocate function reinterprets this as the proper object type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- void ** </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3_icgraph.svg" width="320" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4acc34ebbad9df32f54ae8c618ffa0c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_allocate_n </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_allocate_n - copies std::ref's to the data structure passed in by ptr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>ptr, void* dereferenced std::vector </td></tr>
    <tr><td class="paramname">-</td><td>n, const std::size_t </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a4acc34ebbad9df32f54ae8c618ffa0c0_icgraph.svg" width="360" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab3e42eddd74c0c5ce4a640c0cc022245"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_insert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const raft::signal &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>iterator_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_insert - inserts a range from ptr_begin to ptr_end and inserts the signal at the last element inserted, the rest of the signals are set to raft::none. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr_begin</td><td>- void* </td></tr>
    <tr><td class="paramname">ptr_end</td><td>- void* </td></tr>
    <tr><td class="paramname">signal</td><td>- const raft::signal&amp; </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_ab3e42eddd74c0c5ce4a640c0cc022245_icgraph.svg" width="280" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="afc960790e2803da85fa24e64c61c38b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_peek </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::signal *&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_peek - peeks at the head of the queue, the element may be modified but not erased. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- void** </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal* </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_afc960790e2803da85fa24e64c61c38b5_icgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8056adb06fadf2b7aae4d9858795be45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_peek_range </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>curr_pointer_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_peek_range - peeks at head of queue with the specified range, data may be modified but not erased. Since the queue might be non-contiguous then we must return the memory location of each element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- void**, pointer to pointers at which to store the pointers to items on the queue </td></tr>
    <tr><td class="paramname">sig</td><td>- void**, same as above but for signal queue </td></tr>
    <tr><td class="paramname">n_items</td><td>- const std::size_t, number of items requested </td></tr>
    <tr><td class="paramname">curr_pointer_loc</td><td>- number of items able to be returned </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a8056adb06fadf2b7aae4d9858795be45_icgraph.svg" width="355" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad7ca430a795bbf0904c041dcdfd836a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_pop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::signal *&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_pop - makes a copy, pops an item from the queue and stores the copy at memory located at *ptr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- void* </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal* </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_ad7ca430a795bbf0904c041dcdfd836a4_icgraph.svg" width="259" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6edc6a38e9cb2e13eae8afe0703236d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_pop_range </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_pop_range - pops a range, of n_items and stores them to the array of T* items pointed to by ptr_data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr_data</td><td>- void* </td></tr>
    <tr><td class="paramname">n_items</td><td>- std::size_t </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a6edc6a38e9cb2e13eae8afe0703236d7_icgraph.svg" width="339" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4ef48ce2cb02e8bd5d381bb65687e6cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_push </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const raft::signal &amp;&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_push - pushes the object reference by the void ptr and pushes it to the <a class="el" href="class_f_i_f_o.html">FIFO</a> with the associated signal. Once this function returns, the value is copied according to the objects copy constructor, which should be set up to "deep" copy the object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>- void* </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal reference </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a4ef48ce2cb02e8bd5d381bb65687e6cb_icgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1f898343d6c6caf98f5434964d43f627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::local_recycle </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>local_recycle - called by template recycle function after calling destructor (for non-POD types). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>- std::size_t </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 3 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a16fd3ad9300e6ea9deb88677181c2a3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; FIFO::peek </td>
          <td>(</td>
          <td class="paramtype">raft::signal *&#160;</td>
          <td class="paramname"><em>signal</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>peek - returns a reference to the head of the queue. <a class="el" href="class_f_i_f_o.html#aa0cbb6c4a5b8783af38c6deb1a6f651e">unpeek()</a> must be called after this to tell the runtime that the reference is no longer being used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>- raft::signal, default: nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a16fd3ad9300e6ea9deb88677181c2a3c_cgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4eebb934a2d29c17916eb21db85fd39d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto FIFO::peek_range </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> -&gt; autorelease&lt; T, peekrange &gt;
   </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>peek_range - analogous to peek, only the user gets a list of items. <a class="el" href="class_f_i_f_o.html#aa0cbb6c4a5b8783af38c6deb1a6f651e">unpeek()</a> must be called after using this function to let the runtime know that the user is done with the references. @ n - const std::size_t, number of items to peek </p><dl class="section return"><dt>Returns</dt><dd>- std::vector&lt; std::reference_wrapper&lt; T &gt; &gt; </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a4eebb934a2d29c17916eb21db85fd39d_cgraph.svg" width="355" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0607b6c931ed1fab618e637af617dd15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::pop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raft::signal *&#160;</td>
          <td class="paramname"><em>signal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>pop - pops the head of the queue. If the receiving object wants to watch use the signal, then the signal parameter should not be null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- T&amp; </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a0607b6c931ed1fab618e637af617dd15_cgraph.svg" width="259" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a23be63e817ff487d32013064e752f02f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::pop_range </td>
          <td>(</td>
          <td class="paramtype">pop_range_t&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>pop_range - pops n_items from the buffer into the std::vector pointed to by pop_range. There are two different ways this function could operate, either with a push_back type symantic which would mean three copies or dealing with a pre-allocated vector. This function assumes that the user has allocated a vector withthe correct size (= n_items). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>- std::vector&lt; std::pair&lt; T, raft::signal &gt; &gt;&amp; </td></tr>
    <tr><td class="paramname">n_items</td><td>- std::size_t </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a23be63e817ff487d32013064e752f02f_cgraph.svg" width="339" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a381974271d6c818473edd23c355f0d36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const raft::signal&#160;</td>
          <td class="paramname"><em>signal</em> = <code>raft::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>push - function which takes an object of type T and a signal, makes a copy of the object using the copy constructor and passes it to the <a class="el" href="class_f_i_f_o.html">FIFO</a> along with the signal which is guaranteed to be delivered at the same time as the object (if of course the receiving object is responding to signals). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- T&amp; </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal, default raft::none </td></tr>
  </table>
  </dd>
</dl>
<p>call blocks till element is written and released to queue </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_a381974271d6c818473edd23c355f0d36_cgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa848776c8d7b4966a8531b670c429e98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const raft::signal&#160;</td>
          <td class="paramname"><em>signal</em> = <code>raft::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>push - function which takes an object of type T and a signal, makes a copy of the object using the copy constructor and passes it to the <a class="el" href="class_f_i_f_o.html">FIFO</a> along with the signal which is guaranteed to be delivered at the same time as the object (if of course the receiving object is responding to signals). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- T&amp;&amp; </td></tr>
    <tr><td class="paramname">signal</td><td>- raft::signal, default raft::none </td></tr>
  </table>
  </dd>
</dl>
<p>TODO, think about changing this, erasing type is always ugly</p>
<p>call blocks till element is written and released to queue </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_aa848776c8d7b4966a8531b670c429e98_cgraph.svg" width="270" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab58f3828e61026c45f8aacb13160aa81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; std::is_pod&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIFO::recycle </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>range</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>recycle - so you want to ignore some items from the input stream without ever even looking at them, then this is the function for you. It is also used with the peek call in order to invalidate or free memory to the queue so that the next peek or pop operation will see a a different location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- refernce to object or type of object to be recycled, can be null or invalid since this function will never access it. </td></tr>
    <tr><td class="paramname">range</td><td>- const std::size_t </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 4 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a27264d14b86811604a54e0d30aa22c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::resize </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile bool &amp;&#160;</td>
          <td class="paramname"><em>exit_alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>resize - called from the dynamic allocator to resize the queue. The function itself is implemented in the various template specializations found in ringuffer.tcc. A new queue is allocated with the size specified and alignment and the old queue is copied over. The third parameter, exit_alloc must be passed from the dynamic allocator to signal with the application is finished so that the resize function doesn't wait indefinitely for queue conditions that will never arise (for exact conditions, see datamanager.tcc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_items</td><td>- number of items to resize q to </td></tr>
    <tr><td class="paramname">align</td><td>- alignment of queue to allocate </td></tr>
    <tr><td class="paramname">exit_alloc</td><td>- bool to signal when app is finished </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bb564ddace3951ed7754a285b438ba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::send </td>
          <td>(</td>
          <td class="paramtype">const raft::signal&#160;</td>
          <td class="paramname"> = <code>raft::none</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>send - releases the last item allocated by <a class="el" href="class_f_i_f_o.html#a43ad12d67e3611fafae4d6ed862c60b9">allocate()</a> to the queue. Function will simply return if allocate wasn't called prior to calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>- const raft::signal, default: NONE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0be4de6db251e1a2e6dcc97a5d4a584"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::send_range </td>
          <td>(</td>
          <td class="paramtype">const raft::signal&#160;</td>
          <td class="paramname"> = <code>raft::none</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>send_range - releases the items allocated by allocate_range to the queue. Function will simply return if allocate wasn't called prior to calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal</td><td>- const raft::signal, default: NONE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11422695c75c05ad2c60e662553f2667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::set_dst_kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraft_1_1kernel.html">raft::kernel</a> *const&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set_dst_kernel - sets the protected destination kernel for this fifo, necessary for preemption, see comments on variables below. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- <a class="el" href="classraft_1_1kernel.html">raft::kernel</a>* </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 5 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa9c1f679b4e2585047af2c09a2518209"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::set_src_kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraft_1_1kernel.html">raft::kernel</a> *const&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set_src_kernel - sets teh protected source kernel for this fifo, necessary for preemption, see comments on variables below. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>- <a class="el" href="classraft_1_1kernel.html">raft::kernel</a>* </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 6 -->
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a36a7519af834c969d49f3d9ae7080af9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual raft::signal FIFO::signal_peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>signal_peek - special function for the scheduler to peek at a signal on the head of the queue. </p><dl class="section return"><dt>Returns</dt><dd>raft::signal </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b606d47361489007490e0e0b4e2aa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::signal_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>signal_pop - special function fo rthe scheduler to pop the current signal and associated item. </p>

</div>
</div>
<a class="anchor" id="ae80b8555fc249168560c67cd0a13e574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t FIFO::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>size - returns the current size of this <a class="el" href="class_f_i_f_o.html">FIFO</a> </p><dl class="section return"><dt>Returns</dt><dd>std::size_t </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_f_i_f_o_ae80b8555fc249168560c67cd0a13e574_icgraph.svg" width="464" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac34aa9afd24e536aad0a9553863b6fe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t FIFO::space_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>space_avail - convenience function to get the current space available in the <a class="el" href="class_f_i_f_o.html">FIFO</a>, could otherwise be calculated by taking the <a class="el" href="class_f_i_f_o.html#a64565d7156f6796ff14c3033387043b1">capacity()</a> - <a class="el" href="class_f_i_f_o.html#ae80b8555fc249168560c67cd0a13e574">size()</a>. </p><dl class="section return"><dt>Returns</dt><dd>std::size_t </dd></dl>

</div>
</div>
<a class="anchor" id="aa0cbb6c4a5b8783af38c6deb1a6f651e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FIFO::unpeek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>unpeek - call after peek to let the runtime know that all references to the returned value are no longer in use. Keeps the memory location in a valid state for that input port, i.e., it doesn't release the memory location so that the next call to peek will return the same exact location. A call to recycle will release the memory, or invalidate it. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aae5808dc2e987bf17ef42196457a654d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_schedule.html">Schedule</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>needed to keep as a friend for signalling access </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fifo_8hpp_source.html">fifo.hpp</a></li>
<li>fifo.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 12 2015 12:16:50 for RaftLib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
