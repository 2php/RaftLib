\hypertarget{classraft_1_1map}{}\section{raft\+:\+:map Class Reference}
\label{classraft_1_1map}\index{raft\+::map@{raft\+::map}}


Inheritance diagram for raft\+:\+:map\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=138pt]{classraft_1_1map__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for raft\+:\+:map\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=305pt]{classraft_1_1map__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classraft_1_1map_a058ea3b55858b74bf837cda1058d14fe}{map} ()
\item 
virtual \hyperlink{classraft_1_1map_a9a8bdcfb92f7891f9f5fd981eb1227b6}{$\sim$map} ()=default
\item 
{\footnotesize template$<$class partition  = partition\+\_\+dummy, class scheduler  = simple\+\_\+schedule, class allocator  = dynalloc, class parallelism\+\_\+monitor  = basic\+\_\+parallel$>$ }\\void \hyperlink{classraft_1_1map_a120b4bf6d1dcb186032e972878dd513d}{exe} ()
\item 
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} \hyperlink{classraft_1_1map_ad4bd4cf9bdb1d49e481e572cfdb90476}{operator+=} (\hyperlink{classkpair}{kpair} \&p)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classraft_1_1map_a6d65605c4d3db559332155101ff69e1b}{joink} (\hyperlink{classkpair}{kpair} $\ast$const next)
\item 
void \hyperlink{classraft_1_1map_aad8ce35fdb536b14db16b3462157dcd7}{check\+Edges} (kernelkeeper \&source\+\_\+k)
\item 
void \hyperlink{classraft_1_1map_a9eb65e50373f006fb193c203f8cab7d8}{enable\+Duplication} (kernelkeeper \&\hyperlink{classsource}{source}, kernelkeeper \&all)
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classraft_1_1map_ae75d52e84ecfc11bcaa43dd9fe149a2f}{\+::basic\+\_\+parallel}
\item 
\hypertarget{classraft_1_1map_a59b0d31ff28240338a2b6e682030ca3c}{}\label{classraft_1_1map_a59b0d31ff28240338a2b6e682030ca3c} 
class {\bfseries \+::\+Schedule}
\item 
\hypertarget{classraft_1_1map_a7a76af3f5b64c7a5a034d5399712c4a3}{}\label{classraft_1_1map_a7a76af3f5b64c7a5a034d5399712c4a3} 
class {\bfseries \+::\+Allocate}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 46 of file map.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classraft_1_1map_a058ea3b55858b74bf837cda1058d14fe}{}\label{classraft_1_1map_a058ea3b55858b74bf837cda1058d14fe} 
\index{raft\+::map@{raft\+::map}!map@{map}}
\index{map@{map}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{map()}{map()}}
{\footnotesize\ttfamily raft\+::map\+::map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

map -\/ constructor, really doesn\textquotesingle{}t do too much at the monent and doesn\textquotesingle{}t really need to.

\hyperlink{map_8cpp_source}{map.\+cpp} -\/ \begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Fri Sep 12 10\+:28\+:33 2014
\end{DoxyVersion}
Copyright 2014 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 

Definition at line 39 of file map.\+cpp.


\begin{DoxyCode}
39              : \hyperlink{class_map_base_a5a923d5b3ececb0407aa934d967ab7b1}{MapBase}()
40 \{
41 
42 \}
\end{DoxyCode}
\hypertarget{classraft_1_1map_a9a8bdcfb92f7891f9f5fd981eb1227b6}{}\label{classraft_1_1map_a9a8bdcfb92f7891f9f5fd981eb1227b6} 
\index{raft\+::map@{raft\+::map}!````~map@{$\sim$map}}
\index{````~map@{$\sim$map}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{$\sim$map()}{~map()}}
{\footnotesize\ttfamily virtual raft\+::map\+::$\sim$map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}

default destructor 

\subsection{Member Function Documentation}
\hypertarget{classraft_1_1map_aad8ce35fdb536b14db16b3462157dcd7}{}\label{classraft_1_1map_aad8ce35fdb536b14db16b3462157dcd7} 
\index{raft\+::map@{raft\+::map}!check\+Edges@{check\+Edges}}
\index{check\+Edges@{check\+Edges}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{check\+Edges()}{checkEdges()}}
{\footnotesize\ttfamily void raft\+::map\+::check\+Edges (\begin{DoxyParamCaption}\item[{kernelkeeper \&}]{source\+\_\+k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

check\+Edges -\/ runs a breadth first search through the graph to look for disconnected edges. 
\begin{DoxyParams}{Parameters}
{\em source\+\_\+k} & -\/ std\+::set$<$ raft\+::kernel$\ast$ $>$ \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_port_exception}{Port\+Exception}} & -\/ thrown if an unconnected edge is found. \\
\hline
\end{DoxyExceptions}
N\+O\+TE\+: will throw an error that we\textquotesingle{}re not catching here if there are unconnected edges...this is something that a user will have to fix. Otherwise will return with no errors.

Definition at line 45 of file map.\+cpp.



References Graph\+Tools\+::\+B\+F\+S().



Referenced by exe().


\begin{DoxyCode}
46 \{
47    \textcolor{keyword}{auto} &container( source\_k.acquire() );\textcolor{comment}{}
48 \textcolor{comment}{   /**}
49 \textcolor{comment}{    * NOTE: will throw an error that we're not catching here}
50 \textcolor{comment}{    * if there are unconnected edges...this is something that}
51 \textcolor{comment}{    * a user will have to fix.  Otherwise will return with no}
52 \textcolor{comment}{    * errors.}
53 \textcolor{comment}{    */}
54    \hyperlink{class_graph_tools_ade51007699cbd681c1a37946609c46ee}{GraphTools::BFS}( container,
55                     []( \hyperlink{struct_port_info}{PortInfo} &  a, 
56                         \hyperlink{struct_port_info}{PortInfo} &  b, 
57                         \textcolor{keywordtype}{void} *  \textcolor{keyword}{const} data )
58                     \{
59                        UNUSED( a );
60                        UNUSED( b );
61                        UNUSED( data );
62                        \textcolor{keywordflow}{return};
63                     \},
64                     \textcolor{keyword}{nullptr},
65                     true );
66    source\_k.release();
67    \textcolor{keywordflow}{return};
68 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{classraft_1_1map_aad8ce35fdb536b14db16b3462157dcd7_cgraph}
\end{center}
\end{figure}
\hypertarget{classraft_1_1map_a9eb65e50373f006fb193c203f8cab7d8}{}\label{classraft_1_1map_a9eb65e50373f006fb193c203f8cab7d8} 
\index{raft\+::map@{raft\+::map}!enable\+Duplication@{enable\+Duplication}}
\index{enable\+Duplication@{enable\+Duplication}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{enable\+Duplication()}{enableDuplication()}}
{\footnotesize\ttfamily void raft\+::map\+::enable\+Duplication (\begin{DoxyParamCaption}\item[{kernelkeeper \&}]{source,  }\item[{kernelkeeper \&}]{all }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

enable\+Duplication -\/ add split / join kernels where needed, for the moment we\textquotesingle{}re going with a simple split/join topology, however that doesn\textquotesingle{}t mean that more complex topologies might not be implemented in the future. 
\begin{DoxyParams}{Parameters}
{\em source\+\_\+k} & -\/ std\+::set$<$ raft\+::kernel$\ast$ $>$ with sources\\
\hline
\end{DoxyParams}
void insert( \hyperlink{classraft_1_1kernel}{raft\+::kernel} \&a, \hyperlink{struct_port_info}{Port\+Info} \&a\+\_\+out, \hyperlink{classraft_1_1kernel}{raft\+::kernel} \&b, \hyperlink{struct_port_info}{Port\+Info} \&b\+\_\+in, \hyperlink{classraft_1_1kernel}{raft\+::kernel} \&i, \hyperlink{struct_port_info}{Port\+Info} \&i\+\_\+in, \hyperlink{struct_port_info}{Port\+Info} \&i\+\_\+out ); don\textquotesingle{}t have to do this but it makes it far more apparent where it comes from

need to grab impl of Lengauer and Tarjan dominators, use for S\+E\+SE

in the interim, restrict to kernels that are simple to duplicate

N\+O\+TE\+: there\textquotesingle{}s a better linear S\+E\+SE algorithm jcb17\+May16

case of inline kernel

front -\/$>$ kernel\+\_\+a goes to front -\/$>$ split -\/$>$ kernel\+\_\+a

now we need the port info from the input port on back

kernel\+\_\+a -\/$>$ back goes to kernel\+\_\+a -\/$>$ join -\/$>$ back

finally set the flag to the scheduler so that the parallel map manager can pick it up an use it.

parallalizable source, single output no inputs

parallelizable sink, single input, no outputs

flag as candidate if the connecting kernel only has one input port.

simply flag as a candidate 

Definition at line 76 of file map.\+cpp.



References Graph\+Tools\+::\+B\+F\+S(), Port\+::count(), raft\+::kernel\+::input, Map\+Base\+::join(), and Port\+Info\+::split\+\_\+func.



Referenced by exe().


\begin{DoxyCode}
77 \{
78     \textcolor{keyword}{auto} &source\_k( \hyperlink{classsource}{source}.acquire() );
79     \textcolor{keyword}{auto} &all\_k   ( all.acquire()    );\textcolor{comment}{}
80 \textcolor{comment}{    /** don't have to do this but it makes it far more apparent where it comes from **/}
81     \textcolor{keywordtype}{void} * \textcolor{keyword}{const} kernel\_ptr( reinterpret\_cast< void* >( &all\_k ) );
82     \textcolor{keyword}{using} kernel\_ptr\_t = std::remove\_reference< decltype( all\_k ) >::type;\textcolor{comment}{}
83 \textcolor{comment}{    /** need to grab impl of Lengauer and Tarjan dominators, use for SESE **/}\textcolor{comment}{}
84 \textcolor{comment}{    /** in the interim, restrict to kernels that are simple to duplicate **/}\textcolor{comment}{}
85 \textcolor{comment}{    /** NOTE: there's a better linear SESE algorithm jcb17May16 **/}
86     \hyperlink{class_graph_tools_ade51007699cbd681c1a37946609c46ee}{GraphTools::BFS}( source\_k,
87                      []( \hyperlink{struct_port_info}{PortInfo} &a, \hyperlink{struct_port_info}{PortInfo} &b, \textcolor{keywordtype}{void} *data )
88                      \{
89                         \textcolor{keyword}{auto} * \textcolor{keyword}{const} all\_k( reinterpret\_cast< kernel\_ptr\_t* >( data ) );
90                         \textcolor{keywordflow}{if}( a.out\_of\_order && b.out\_of\_order )
91                         \{\textcolor{comment}{}
92 \textcolor{comment}{                           /** case of inline kernel **/}
93                            \textcolor{keywordflow}{if}( b.my\_kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 1 &&
94                                b.my\_kernel->output.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 1 &&
95                                a.my\_kernel->dup\_candidate  )
96                            \{
97                               \textcolor{keyword}{auto} *kernel\_a( a.my\_kernel );
98                               assert( kernel\_a->input.count() == 1 );
99                               \textcolor{keyword}{auto} &port\_info\_front( kernel\_a->input.getPortInfo() );
100                               \textcolor{keyword}{auto} *front( port\_info\_front.other\_kernel );
101                               \textcolor{keyword}{auto} &front\_port\_info( front->output.getPortInfo() );\textcolor{comment}{}
102 \textcolor{comment}{                              /**}
103 \textcolor{comment}{                               * front -> kernel\_a goes to}
104 \textcolor{comment}{                               * front -> split -> kernel\_a}
105 \textcolor{comment}{                               */}
106                               \textcolor{keyword}{auto} *split(
107                                  static\_cast< raft::kernel* >(
108                                     port\_info\_front.split\_func() ) );
109                               all\_k->insert( split );
110                               MapBase::insert( front,    front\_port\_info,
111                                                kernel\_a, port\_info\_front,
112                                                split );
113 
114                               assert( kernel\_a->output.count() == 1 );
115 \textcolor{comment}{}
116 \textcolor{comment}{                              /**}
117 \textcolor{comment}{                               * now we need the port info from the input}
118 \textcolor{comment}{                               * port on back}
119 \textcolor{comment}{                               **/}
120 \textcolor{comment}{}
121 \textcolor{comment}{                              /**}
122 \textcolor{comment}{                               * kernel\_a -> back goes to}
123 \textcolor{comment}{                               * kernel\_a -> join -> back}
124 \textcolor{comment}{                               */}
125                               \textcolor{keyword}{auto} *\hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}( static\_cast< raft::kernel* >( a.join\_func() ) );
126                               all\_k->insert( \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join} );
127                               MapBase::insert( a.my\_kernel, a,
128                                                b.my\_kernel, b,
129                                                \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join} );\textcolor{comment}{}
130 \textcolor{comment}{                              /**}
131 \textcolor{comment}{                               * finally set the flag to the scheduler}
132 \textcolor{comment}{                               * so that the parallel map manager can}
133 \textcolor{comment}{                               * pick it up an use it.}
134 \textcolor{comment}{                               */}
135                               a.my\_kernel->dup\_enabled = \textcolor{keyword}{true};
136                            \}\textcolor{comment}{}
137 \textcolor{comment}{                           /** parallalizable source, single output no inputs**/}
138                            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( a.my\_kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 0 &&
139                                     a.my\_kernel->output.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 1 )
140                            \{
141                               \textcolor{keyword}{auto} *\hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}( static\_cast< raft::kernel* >( a.join\_func() ) );
142                               all\_k->insert( \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join} );
143                               MapBase::insert( a.my\_kernel, a,
144                                                b.my\_kernel, b,
145                                                \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join} );
146                               a.my\_kernel->dup\_enabled = \textcolor{keyword}{true};
147                            \}\textcolor{comment}{}
148 \textcolor{comment}{                           /** parallelizable sink, single input, no outputs **/}
149                            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( b.my\_kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 1 &&
150                                     b.my\_kernel->output.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 0 )
151                            \{
152                               \textcolor{keyword}{auto} *split(
153                                  static\_cast< raft::kernel* >( b.\hyperlink{struct_port_info_a6b7e8758b84288a4378233251252be77}{split\_func}() ) );
154                               all\_k->insert( split );
155                               MapBase::insert( a.my\_kernel, a,
156                                                b.my\_kernel, b,
157                                                split );
158                               b.my\_kernel->dup\_enabled = \textcolor{keyword}{true};
159                            \}\textcolor{comment}{}
160 \textcolor{comment}{                           /**}
161 \textcolor{comment}{                            * flag as candidate if the connecting}
162 \textcolor{comment}{                            * kernel only has one input port.}
163 \textcolor{comment}{                            */}
164                            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( b.my\_kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a33562ea87ac7e83a32441da40cbd9279}{count}() == 1 )
165                            \{\textcolor{comment}{}
166 \textcolor{comment}{                              /** simply flag as a candidate **/}
167                               b.my\_kernel->dup\_candidate = \textcolor{keyword}{true};
168                            \}
169 
170                         \}
171                      \},
172                      kernel\_ptr,
173                      false );
174    \hyperlink{classsource}{source}.release();
175    all.release();
176 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classraft_1_1map_a9eb65e50373f006fb193c203f8cab7d8_cgraph}
\end{center}
\end{figure}
\hypertarget{classraft_1_1map_a120b4bf6d1dcb186032e972878dd513d}{}\label{classraft_1_1map_a120b4bf6d1dcb186032e972878dd513d} 
\index{raft\+::map@{raft\+::map}!exe@{exe}}
\index{exe@{exe}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{exe()}{exe()}}
{\footnotesize\ttfamily template$<$class partition  = partition\+\_\+dummy, class scheduler  = simple\+\_\+schedule, class allocator  = dynalloc, class parallelism\+\_\+monitor  = basic\+\_\+parallel$>$ \\
void raft\+::map\+::exe (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

F\+I\+X\+ME, the graph tools need to take more than function, we\textquotesingle{}re wasting time by traversing the graph twice....will take awhile with big graphs. check types, ensure all are linked

adds in split/join kernels

launch allocator in a thread

launch scheduler in thread

launch parallelism monitor

ref to this

allocator

scheduler

exit parameter

join scheduler first

scheduler done, cleanup alloc

no more need to duplicate kernels

all fifo\textquotesingle{}s deallocated when alloc goes out of scope 

Definition at line 92 of file map.\+hpp.



References Map\+Base\+::all\+\_\+kernels, check\+Edges(), enable\+Duplication(), joink(), operator+=(), Map\+Base\+::source\+\_\+kernels, and Map\+Base\+::sub\+\_\+maps.



Referenced by sum$<$ T $>$\+::run(), Generate$<$ T $>$\+::run(), print$<$ T $>$\+::run(), Sum$<$ A, B, C $>$\+::run(), sub$<$ T $>$\+::run(), display$<$ T $>$\+::run(), and last\+::run().


\begin{DoxyCode}
93    \{
94       \{
95          \textcolor{keyword}{auto} &container( \hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\_kernels}.acquire() );
96          \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} * \textcolor{keyword}{const} submap : \hyperlink{class_map_base_abc4856ed552e77510211851f0a4a02ab}{sub\_maps} )
97          \{
98             \textcolor{keyword}{auto} &subcontainer( submap->all\_kernels.acquire() );  
99             container.insert( subcontainer.begin(),
100                               subcontainer.end()   );
101             submap->all\_kernels.release();
102          \}
103          \hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\_kernels}.release();
104       \}\textcolor{comment}{}
105 \textcolor{comment}{      /** check types, ensure all are linked **/}
106       \hyperlink{classraft_1_1map_aad8ce35fdb536b14db16b3462157dcd7}{checkEdges}( \hyperlink{class_map_base_a2541cb37a237e66fc88129f9f0b02f50}{source\_kernels} );
107       partition pt;
108       pt.partition( \hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\_kernels} );
109       \textcolor{comment}{}
110 \textcolor{comment}{      /** adds in split/join kernels **/}
111       \textcolor{comment}{//enableDuplication( source\_kernels, all\_kernels );}
112       \textcolor{keyword}{volatile} \textcolor{keywordtype}{bool} exit\_alloc( \textcolor{keyword}{false} );
113       allocator alloc( (*\textcolor{keyword}{this}), exit\_alloc );\textcolor{comment}{}
114 \textcolor{comment}{      /** launch allocator in a thread **/}
115       std::thread mem\_thread( [&]()\{
116          alloc.run();
117       \});
118      
119       alloc.waitTillReady();
120 
121       scheduler sched( (*\textcolor{keyword}{this}) );
122       sched.init();
123       \textcolor{comment}{}
124 \textcolor{comment}{      /** launch scheduler in thread **/}
125       std::thread sched\_thread( [&]()\{
126          sched.start();
127       \});
128 
129       \textcolor{keyword}{volatile} \textcolor{keywordtype}{bool} exit\_para( \textcolor{keyword}{false} );\textcolor{comment}{}
130 \textcolor{comment}{      /** launch parallelism monitor **/}
131       parallelism\_monitor pm( (*\textcolor{keyword}{this})     \textcolor{comment}{/** ref to this    **/}, 
132                               alloc       \textcolor{comment}{/** allocator      **/},
133                               sched       \textcolor{comment}{/** scheduler      **/},
134                               exit\_para   \textcolor{comment}{/** exit parameter **/});
135       std::thread parallel\_mon( [&]()\{
136          pm.start();
137       \});\textcolor{comment}{}
138 \textcolor{comment}{      /** join scheduler first **/}
139       sched\_thread.join();
140 \textcolor{comment}{}
141 \textcolor{comment}{      /** scheduler done, cleanup alloc **/}
142       exit\_alloc = \textcolor{keyword}{true};
143       mem\_thread.join();\textcolor{comment}{}
144 \textcolor{comment}{      /** no more need to duplicate kernels **/}
145       exit\_para = \textcolor{keyword}{true};
146       parallel\_mon.join();
147 \textcolor{comment}{}
148 \textcolor{comment}{      /** all fifo's deallocated when alloc goes out of scope **/}
149       \textcolor{keywordflow}{return}; 
150    \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classraft_1_1map_a120b4bf6d1dcb186032e972878dd513d_cgraph}
\end{center}
\end{figure}
\hypertarget{classraft_1_1map_a6d65605c4d3db559332155101ff69e1b}{}\label{classraft_1_1map_a6d65605c4d3db559332155101ff69e1b} 
\index{raft\+::map@{raft\+::map}!joink@{joink}}
\index{joink@{joink}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{joink()}{joink()}}
{\footnotesize\ttfamily void raft\+::map\+::joink (\begin{DoxyParamCaption}\item[{\hyperlink{classkpair}{kpair} $\ast$const}]{next }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

joink -\/ convenience function for joining kernels from kpair objects 
\begin{DoxyParams}{Parameters}
{\em next} & -\/ kpair$\ast$ const, kpair created from linking process \\
\hline
\end{DoxyParams}
might be able to do better by re-\/doing with templates

single input, single output, hopefully 

Definition at line 179 of file map.\+cpp.



References Map\+Base\+::link().



Referenced by exe(), and operator+=().


\begin{DoxyCode}
180 \{\textcolor{comment}{}
181 \textcolor{comment}{        /** might be able to do better by re-doing with templates **/}
182         \textcolor{keywordflow}{if}( next->has\_src\_name && next->has\_dst\_name )
183         \{
184             \textcolor{keywordflow}{if}( next->out\_of\_order )
185             \{
186                 (\textcolor{keyword}{this})->link< raft::order::out >( next->src,
187                                                   next->src\_name,
188                                                   next->dst,
189                                                   next->dst\_name );
190             \}
191             \textcolor{keywordflow}{else}
192             \{
193                 (\textcolor{keyword}{this})->\hyperlink{class_map_base_ad98ef02c1651130ad6b565ad156b97c1}{link}( next->src,
194                               next->src\_name,
195                               next->dst,
196                               next->dst\_name );
197 
198             \}
199         \}
200         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( next->has\_src\_name && ! next->has\_dst\_name )
201         \{
202             \textcolor{keywordflow}{if}( next->out\_of\_order )
203             \{
204                 (\textcolor{keyword}{this})->link< raft::order::out >( next->src,
205                                                   next->src\_name,
206                                                   next->dst );
207             \}
208             \textcolor{keywordflow}{else}
209             \{
210                 (\textcolor{keyword}{this})->\hyperlink{class_map_base_ad98ef02c1651130ad6b565ad156b97c1}{link}( next->src,
211                               next->src\_name,
212                               next->dst );
213             \}
214         \}
215         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ! next->has\_src\_name && next->has\_dst\_name )
216         \{
217             \textcolor{keywordflow}{if}( next->out\_of\_order )
218             \{
219                 (\textcolor{keyword}{this})->link< raft::order::out >( next->src,
220                                                   next->dst,
221                                                   next->dst\_name );
222             \}
223             \textcolor{keywordflow}{else}
224             \{
225                 (\textcolor{keyword}{this})->\hyperlink{class_map_base_ad98ef02c1651130ad6b565ad156b97c1}{link}( next->src,
226                               next->dst,
227                               next->dst\_name );
228             \}
229         \}
230         \textcolor{keywordflow}{else} \textcolor{comment}{/** single input, single output, hopefully **/}
231         \{
232             \textcolor{keywordflow}{if}( next->out\_of\_order )
233             \{
234                 (\textcolor{keyword}{this})->link< raft::order::out >( next->src,
235                                                   next->dst );
236             \}
237             \textcolor{keywordflow}{else}
238             \{
239                 (\textcolor{keyword}{this})->\hyperlink{class_map_base_ad98ef02c1651130ad6b565ad156b97c1}{link}( next->src,
240                               next->dst );
241             \}
242         \}
243 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classraft_1_1map_a6d65605c4d3db559332155101ff69e1b_cgraph}
\end{center}
\end{figure}
\hypertarget{classraft_1_1map_ad4bd4cf9bdb1d49e481e572cfdb90476}{}\label{classraft_1_1map_ad4bd4cf9bdb1d49e481e572cfdb90476} 
\index{raft\+::map@{raft\+::map}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{operator+=()}{operator+=()}}
{\footnotesize\ttfamily \hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} raft\+::map\+::operator+= (\begin{DoxyParamCaption}\item[{\hyperlink{classkpair}{kpair} \&}]{p }\end{DoxyParamCaption})}

invoked to add kernel links to the map, returns an iterator to a list of the last kernels added to the map via the += start at the head, go forward

init return struct

set to true when we\textquotesingle{}ve done the first pass so that the ret\+\_\+kernel\+\_\+pair has the correct source kernels for this addition to the map most of the time this will look just like a \textquotesingle{}$>$$>$\textquotesingle{} op, but others this will get quite complicated

used to do nested splits

dup kernels arranged in \char`\"{}groups\char`\"{} so that a =$<$ b a -\/$>$ b1 a -\/$>$ b2 and b$^\wedge$n is one group each kernel attached to b$^\wedge$n is then chained group to group until we reduce

keep \# of out-\/edges for splits

could throw an exception so use push\+\_\+back

start kernels vector off emplace used since kernel can\textquotesingle{}t throw an exception

hold on to these for a bit so we can back track if needed

loop over chain

mult kernels going ot single kernel

whoops, looks like we need to clear the source ret\+\_\+kernel\+\_\+pair. also reset initialized so we capture all the new source kernels that are added.

unique ptr

don\textquotesingle{}t need these anymore

now old dst (in temp\+\_\+groups) become new sources

groups should now have the final destinations across multiple groups potentially. Take these, flatten to a single destination for the return vector since this is what the specification expects (i.\+e., all actual end destinations added to map....which are the last kernels added or leaf nodes).

unique ptr

T\+O\+DO, need to get the \hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} to return the full list of kernels. Basically need to go back and pass the \hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} through the split/cont/join in order ot get the right kernels into the list, especially ones that are cloned internally otherwise the user might not get the returns that the expected.

Definition at line 248 of file map.\+cpp.



References kernel\+\_\+pair\+\_\+t\+::add\+Dst(), kernel\+\_\+pair\+\_\+t\+::add\+Src(), Port\+::begin(), kernel\+\_\+pair\+\_\+t\+::clear\+Src(), raft\+::kernel\+::clone(), Port\+::count(), Port\+::end(), raft\+::kernel\+::input, Map\+Base\+::join(), and joink().



Referenced by exe().


\begin{DoxyCode}
249 \{
250     \hyperlink{classkpair}{kpair} * \textcolor{keyword}{const} pair( &p );
251     assert( pair != \textcolor{keyword}{nullptr} );
252     \textcolor{comment}{}
253 \textcolor{comment}{    /** start at the head, go forward **/}
254     \hyperlink{classkpair}{kpair} *next = pair->head;
255     assert( next != \textcolor{keyword}{nullptr} );
256     \textcolor{comment}{}
257 \textcolor{comment}{    /** init return struct **/}
258     \hyperlink{classkernel__pair__t}{kernel\_pair\_t} ret\_kernel\_pair;
259     \textcolor{comment}{}
260 \textcolor{comment}{    /** }
261 \textcolor{comment}{     * set to true when we've done the first pass}
262 \textcolor{comment}{     * so that the ret\_kernel\_pair has the correct}
263 \textcolor{comment}{     * source kernels for this addition to the map}
264 \textcolor{comment}{     * most of the time this will look just like}
265 \textcolor{comment}{     * a '>>' op, but others this will get quite}
266 \textcolor{comment}{     * complicated}
267 \textcolor{comment}{     */}
268     \textcolor{keywordtype}{bool} initialized( \textcolor{keyword}{false} );
269     \textcolor{comment}{}
270 \textcolor{comment}{    /** used to do nested splits **/}
271     \textcolor{keyword}{enum} sj\_t : std::int8\_t \{ split, \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}, cont \};
272     \textcolor{keyword}{const} \textcolor{keyword}{static} std::array< std::string, 3 > sj\_t\_str( 
273         \{\{ \textcolor{stringliteral}{"split"}, \textcolor{stringliteral}{"join"}, \textcolor{stringliteral}{"cont"} \}\} 
274     );
275 
276     \textcolor{keyword}{auto} next\_link\_type( []( \textcolor{keyword}{const} \hyperlink{classkpair}{kpair} * \textcolor{keyword}{const} k ) -> sj\_t
277     \{
278         \textcolor{keywordflow}{if}( k->split\_to && ! k->join\_from )
279         \{
280             return( split );
281         \}
282         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ! k->split\_to && k->join\_from )
283         \{
284             return( join );
285         \}
286         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ! k->split\_to && ! k->join\_from )
287         \{
288             return( cont );
289         \}
290         \textcolor{keywordflow}{else}
291         \{
292             throw InvalidTopologyOperationException( \textcolor{stringliteral}{"Invalid ordering of topology operators \(\backslash\)"<=\(\backslash\)", \(\backslash\)">>\(\backslash\)"
      , \(\backslash\)">=.\(\backslash\)" Please check and try again\(\backslash\)n"} );
293         \}
294         \textcolor{comment}{//should never reach here **/}
295         assert( \textcolor{keyword}{false} );
296         \textcolor{keywordflow}{return}( cont );
297     \});
298 
299     std::stack< sj\_t > stack;\textcolor{comment}{}
300 \textcolor{comment}{    /**}
301 \textcolor{comment}{     * dup kernels arranged in "groups" so that}
302 \textcolor{comment}{     * a =< b}
303 \textcolor{comment}{     * a -> b1}
304 \textcolor{comment}{     * a -> b2}
305 \textcolor{comment}{     * and b^n is one group}
306 \textcolor{comment}{     * each kernel attached to b^n is}
307 \textcolor{comment}{     * then chained group to group}
308 \textcolor{comment}{     * until we reduce}
309 \textcolor{comment}{     */}
310     kernels\_t  groups;
311 \textcolor{comment}{}
312 \textcolor{comment}{    /**}
313 \textcolor{comment}{     * keep # of out-edges for splits}
314 \textcolor{comment}{     */}
315     split\_stack\_t split\_out\_edges;
316 \textcolor{comment}{}
317 \textcolor{comment}{    /** could throw an exception so use push\_back **/}
318     groups.push\_back( up\_group\_t( \textcolor{keyword}{new} group\_t( ) ) );\textcolor{comment}{}
319 \textcolor{comment}{    /**}
320 \textcolor{comment}{     * start kernels vector off}
321 \textcolor{comment}{     * emplace used since kernel can't throw an exception}
322 \textcolor{comment}{     */}
323     groups.back()->emplace\_back( next->src );
324 \textcolor{comment}{}
325 \textcolor{comment}{    /** hold on to these for a bit so we can back track if needed **/}
326     std::vector< kpair* > kpair\_store;
327 \textcolor{comment}{}
328 \textcolor{comment}{    /** loop over chain **/}
329     \textcolor{keywordflow}{while}( next != \textcolor{keyword}{nullptr} )
330     \{
331         stack.push( next\_link\_type( next ) );
332         decltype( groups ) temp\_groups;
333         switch( stack.top() )
334         \{
335             \textcolor{keywordflow}{case}( cont ):
336             \{
337                 inline\_cont( groups,
338                              temp\_groups,
339                              next );
340                 \textcolor{comment}{//done, move on}
341                 stack.pop();
342             \}
343             \textcolor{keywordflow}{break};
344             \textcolor{keywordflow}{case}( split ):
345             \{
346                 inline\_split( split\_out\_edges,
347                               groups,
348                               temp\_groups,
349                               next );
350             \}
351             \textcolor{keywordflow}{break};
352             \textcolor{keywordflow}{case}( \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join} ):
353             \{
354                 \textcolor{comment}{//make sure something bad didn't happen}
355                 stack.pop();
356                 \textcolor{keywordflow}{if}( stack.size() == 0  \textcolor{comment}{/** mult kernels going ot single kernel **/} )
357                 \{\textcolor{comment}{}
358 \textcolor{comment}{                    /** }
359 \textcolor{comment}{                     * whoops, looks like we need to clear the source }
360 \textcolor{comment}{                     * ret\_kernel\_pair. also reset initialized so we }
361 \textcolor{comment}{                     * capture all the new source kernels that are added.}
362 \textcolor{comment}{                     */}
363                     ret\_kernel\_pair.\hyperlink{classkernel__pair__t_a853076440144fbb3c5a3524536a46336}{clearSrc}();
364                     initialized = \textcolor{keyword}{false};
365                     inline\_dup\_join( groups,
366                                      temp\_groups,
367                                      next );
368                 \}
369                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( stack.top() == split )
370                 \{
371                     \textcolor{comment}{//can pop now, don't need the old split}
372                     stack.pop();
373                     inline\_join( split\_out\_edges,
374                                  groups,
375                                  temp\_groups,
376                                  next );
377                 \}
378                 \textcolor{keywordflow}{else}
379                 \{
380                     assert( \textcolor{keyword}{false} );
381                 \}
382             \}
383             \textcolor{keywordflow}{break};
384             \textcolor{keywordflow}{default}:
385                 assert( \textcolor{keyword}{false} );
386         \}
387 
388         \textcolor{keywordflow}{if}( ! initialized )
389         \{
390             \textcolor{keywordflow}{for}( \textcolor{comment}{/** unique ptr **/} \textcolor{keyword}{auto} &groups\_ptr : groups )
391             \{
392                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} * \textcolor{keyword}{const} kernel : (*groups\_ptr) )
393                 \{
394                     assert( kernel != \textcolor{keyword}{nullptr} );
395                     ret\_kernel\_pair.\hyperlink{classkernel__pair__t_a73351e6699a9243b48df6492f12c83ad}{addSrc}( *kernel );
396                 \}
397             \}
398             initialized = \textcolor{keyword}{true};
399         \}\textcolor{comment}{}
400 \textcolor{comment}{        /** don't need these anymore **/}
401         groups.clear();\textcolor{comment}{}
402 \textcolor{comment}{        /** now old dst (in temp\_groups) become new sources **/}
403         groups = std::move( temp\_groups );
404         
405         \hyperlink{classkpair}{kpair} * \textcolor{keyword}{const} temp\_kpair = next;
406         next = next->next;
407         kpair\_store.emplace\_back( temp\_kpair );
408     \}
409     \textcolor{comment}{}
410 \textcolor{comment}{    /** }
411 \textcolor{comment}{     * groups should now have the final destinations across}
412 \textcolor{comment}{     * multiple groups potentially. Take these, flatten to}
413 \textcolor{comment}{     * a single destination for the return vector since this}
414 \textcolor{comment}{     * is what the specification expects (i.e., all actual}
415 \textcolor{comment}{     * end destinations added to map....which are the last}
416 \textcolor{comment}{     * kernels added or leaf nodes).}
417 \textcolor{comment}{     */}
418     \textcolor{keywordflow}{for}( \textcolor{comment}{/** unique ptr **/} \textcolor{keyword}{auto} &groups\_ptr : groups )
419     \{
420         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} * \textcolor{keyword}{const} kernel : (*groups\_ptr) )
421         \{
422             assert( kernel != \textcolor{keyword}{nullptr} );
423             ret\_kernel\_pair.\hyperlink{classkernel__pair__t_ae22da5b3353d0ccc24d88f87506f5ed4}{addDst}( *kernel );
424         \}
425     \}
426     
427     
428     
429     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} *ptr : kpair\_store )
430     \{
431         \textcolor{keyword}{delete}( ptr );
432     \}
433 \textcolor{comment}{}
434 \textcolor{comment}{    /**}
435 \textcolor{comment}{     * TODO, need to get the kernel\_pair\_t to }
436 \textcolor{comment}{     * return the full list of kernels. Basically}
437 \textcolor{comment}{     * need to go back and pass the kernel\_pair\_t}
438 \textcolor{comment}{     * through the split/cont/join in order ot }
439 \textcolor{comment}{     * get the right kernels into the list, especially}
440 \textcolor{comment}{     * ones that are cloned internally otherwise}
441 \textcolor{comment}{     * the user might not get the returns that}
442 \textcolor{comment}{     * the expected.}
443 \textcolor{comment}{     */}
444     \textcolor{keywordflow}{return}( ret\_kernel\_pair );
445 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classraft_1_1map_ad4bd4cf9bdb1d49e481e572cfdb90476_cgraph}
\end{center}
\end{figure}


\subsection{Friends And Related Function Documentation}
\hypertarget{classraft_1_1map_ae75d52e84ecfc11bcaa43dd9fe149a2f}{}\label{classraft_1_1map_ae75d52e84ecfc11bcaa43dd9fe149a2f} 
\index{raft\+::map@{raft\+::map}!\+::basic\+\_\+parallel@{\+::basic\+\_\+parallel}}
\index{\+::basic\+\_\+parallel@{\+::basic\+\_\+parallel}!raft\+::map@{raft\+::map}}
\subsubsection{\texorpdfstring{\+::basic\+\_\+parallel}{::basic\_parallel}}
{\footnotesize\ttfamily friend class \+::\hyperlink{classbasic__parallel}{basic\+\_\+parallel}\hspace{0.3cm}{\ttfamily [friend]}}

T\+O\+DO, refactor \hyperlink{classbasic__parallel}{basic\+\_\+parallel} base class to match the all caps base class coding style 

Definition at line 191 of file map.\+hpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
map.\+hpp\item 
map.\+cpp\end{DoxyCompactItemize}
