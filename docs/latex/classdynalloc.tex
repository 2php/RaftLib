\hypertarget{classdynalloc}{}\section{dynalloc Class Reference}
\label{classdynalloc}\index{dynalloc@{dynalloc}}


Inheritance diagram for dynalloc\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=133pt]{classdynalloc__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for dynalloc\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=323pt]{classdynalloc__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classdynalloc_ad5aa0343bab70d1f51e05953d890e8d2}{dynalloc} (\hyperlink{classraft_1_1map}{raft\+::map} \&map, volatile bool \&\hyperlink{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{exit\+\_\+alloc})
\item 
virtual void \hyperlink{classdynalloc_a2a52b86ec09bd6dd52e49062137b2e37}{run} ()
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 29 of file dynalloc.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classdynalloc_ad5aa0343bab70d1f51e05953d890e8d2}{}\label{classdynalloc_ad5aa0343bab70d1f51e05953d890e8d2} 
\index{dynalloc@{dynalloc}!dynalloc@{dynalloc}}
\index{dynalloc@{dynalloc}!dynalloc@{dynalloc}}
\subsubsection{\texorpdfstring{dynalloc()}{dynalloc()}}
{\footnotesize\ttfamily dynalloc\+::dynalloc (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1map}{raft\+::map} \&}]{map,  }\item[{volatile bool \&}]{exit\+\_\+alloc }\end{DoxyParamCaption})}

\hyperlink{dynalloc_8cpp_source}{dynalloc.\+cpp} -\/ \begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Mon Oct 13 16\+:36\+:18 2014
\end{DoxyVersion}
Copyright 2014 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 

Definition at line 35 of file dynalloc.\+cpp.


\begin{DoxyCode}
36                                                 :
37                         \hyperlink{class_allocate_ab2b82e7fab9d0fccb9702effec93917b}{Allocate}( map, \hyperlink{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{exit\_alloc} )
38 \{
39 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classdynalloc_a2a52b86ec09bd6dd52e49062137b2e37}{}\label{classdynalloc_a2a52b86ec09bd6dd52e49062137b2e37} 
\index{dynalloc@{dynalloc}!run@{run}}
\index{run@{run}!dynalloc@{dynalloc}}
\subsubsection{\texorpdfstring{run()}{run()}}
{\footnotesize\ttfamily void dynalloc\+::run (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

run -\/ call to initiate schedule, in the current instantiation this is called by the scheduler. same alloc for all, inherit from base alloc

acquire source kernels

make this a fixed quantity right now, if size $>$ .75\% at montor interval three times or more then increase size.

T\+O\+DO, the values might wrap if no monitoring on

get initializer function

start monitor loop

monitor fifo\textquotesingle{}s 

Implements \hyperlink{class_allocate_a44f9b51c382fec159233609e21b9d272}{Allocate}.



Definition at line 65 of file dynalloc.\+cpp.



References Graph\+Tools\+::\+B\+F\+S(), Allocate\+::exit\+\_\+alloc, F\+I\+F\+O\+::get\+\_\+frac\+\_\+write\+\_\+blocked(), Port\+Info\+::get\+F\+I\+F\+O(), Allocate\+::set\+Ready(), and Allocate\+::source\+\_\+kernels.


\begin{DoxyCode}
66 \{
67    \textcolor{keyword}{auto} alloc\_func = [&]( \hyperlink{struct_port_info}{PortInfo} &a, \hyperlink{struct_port_info}{PortInfo} &b, \textcolor{keywordtype}{void} *data )
68    \{\textcolor{comment}{}
69 \textcolor{comment}{      /** same alloc for all, inherit from base alloc **/}
70       (\textcolor{keyword}{this})->allocate( a, b, data );
71    \};
72 \textcolor{comment}{}
73 \textcolor{comment}{   /** acquire source kernels **/}
74    \textcolor{keyword}{auto} &container( (\textcolor{keyword}{this})->\hyperlink{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}{source\_kernels}.acquire() );
75    \hyperlink{class_graph_tools_ade51007699cbd681c1a37946609c46ee}{GraphTools::BFS}( container, alloc\_func );
76    (\textcolor{keyword}{this})->\hyperlink{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}{source\_kernels}.release();
77    (\textcolor{keyword}{this})->\hyperlink{class_allocate_a4cf36bb704e43f5736a0e736d9e1a81b}{setReady}();
78    std::map< std::size\_t, int > size\_map;
79 \textcolor{comment}{}
80 \textcolor{comment}{   /**}
81 \textcolor{comment}{    * make this a fixed quantity right now, if size > .75% at}
82 \textcolor{comment}{    * montor interval three times or more then increase size.}
83 \textcolor{comment}{    */}
84 
85    \textcolor{keyword}{auto} mon\_func = [&]( \hyperlink{struct_port_info}{PortInfo} &a, \hyperlink{struct_port_info}{PortInfo} &b, \textcolor{keywordtype}{void} *data ) -> \textcolor{keywordtype}{void}
86    \{
87       (void) data;
88 
89       \textcolor{keyword}{const} \textcolor{keyword}{auto} hash\_val( dynalloc::hash( a, b ) );\textcolor{comment}{}
90 \textcolor{comment}{      /** TODO, the values might wrap if no monitoring on **/}
91       \textcolor{keyword}{const} \textcolor{keyword}{auto} realized\_ratio( a.\hyperlink{struct_port_info_a483d162fbe356e07381c6c5cfccb4f48}{getFIFO}()->\hyperlink{class_f_i_f_o_a4d44784c43a4026508e85982eb3174c7}{get\_frac\_write\_blocked}() );
92       \textcolor{keyword}{const} \textcolor{keyword}{auto} ratio( 0.8 );
93       \textcolor{keywordflow}{if}( realized\_ratio >= ratio )
94       \{
95          \textcolor{keyword}{const} \textcolor{keyword}{auto} curr\_count( size\_map[ hash\_val ]++ );
96          \textcolor{keywordflow}{if}( curr\_count  > 2 )
97          \{\textcolor{comment}{}
98 \textcolor{comment}{            /** get initializer function **/}
99             \textcolor{keyword}{auto} * \textcolor{keyword}{const} buff\_ptr( a.\hyperlink{struct_port_info_a483d162fbe356e07381c6c5cfccb4f48}{getFIFO}() );
100             \textcolor{keyword}{const} \textcolor{keyword}{auto} cap( buff\_ptr->capacity() );
101             buff\_ptr->resize( cap * 2, ALLOC\_ALIGN\_WIDTH, \hyperlink{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{exit\_alloc} );
102             size\_map[ hash\_val ] = 0;
103          \}
104       \}
105       \textcolor{keywordflow}{return};
106    \};\textcolor{comment}{}
107 \textcolor{comment}{   /** start monitor loop **/}
108    \textcolor{keywordflow}{while}( ! \hyperlink{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{exit\_alloc} )
109    \{\textcolor{comment}{}
110 \textcolor{comment}{      /** monitor fifo's **/}
111       std::chrono::microseconds dura( 3000 );
112       std::this\_thread::sleep\_for( dura );
113 
114       \textcolor{keyword}{auto} &container( (\textcolor{keyword}{this})->\hyperlink{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}{source\_kernels}.acquire() );
115       \hyperlink{class_graph_tools_ade51007699cbd681c1a37946609c46ee}{GraphTools::BFS}( container, mon\_func );
116       (\textcolor{keyword}{this})->\hyperlink{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}{source\_kernels}.release();
117 
118    \}
119    \textcolor{keywordflow}{return};
120 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=296pt]{classdynalloc_a2a52b86ec09bd6dd52e49062137b2e37_cgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dynalloc.\+hpp\item 
dynalloc.\+cpp\end{DoxyCompactItemize}
