\hypertarget{class_map_base}{}\section{Map\+Base Class Reference}
\label{class_map_base}\index{Map\+Base@{Map\+Base}}


{\ttfamily \#include $<$mapbase.\+hpp$>$}



Inheritance diagram for Map\+Base\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=226pt]{class_map_base__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Map\+Base\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=305pt]{class_map_base__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_map_base_a5a923d5b3ececb0407aa934d967ab7b1}{Map\+Base} ()
\item 
virtual \hyperlink{class_map_base_a6c62d788746d2161264b84ba66efcfbe}{$\sim$\+Map\+Base} ()
\item 
{\footnotesize template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ }\\\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} \hyperlink{class_map_base_ad98ef02c1651130ad6b565ad156b97c1}{link} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$a, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$b, const std\+::size\+\_\+t buffer=0)
\item 
{\footnotesize template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ }\\\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} \hyperlink{class_map_base_ad982ebf61439a069ed36dc5f756b732a}{link} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$a, const std\+::string a\+\_\+port, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$b, const std\+::size\+\_\+t buffer=0)
\item 
{\footnotesize template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ }\\\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} \hyperlink{class_map_base_a19a0a2f6842a863327920776457c52bf}{link} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$a, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$b, const std\+::string b\+\_\+port, const std\+::size\+\_\+t buffer=0)
\item 
{\footnotesize template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ }\\\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} \hyperlink{class_map_base_af06481b99a96e3c5ae8da88cc8a78e91}{link} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$a, const std\+::string a\+\_\+port, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$b, const std\+::string b\+\_\+port, const std\+::size\+\_\+t buffer=0)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_map_base_aae7df0d3ff932ba938186e45c6469c02}{}\label{class_map_base_aae7df0d3ff932ba938186e45c6469c02} 
{\footnotesize template$<$class A , class B $>$ }\\void {\bfseries update\+Kernels} (A \&a, B \&b)
\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} \&a, const std\+::string name\+\_\+a, \hyperlink{struct_port_info}{Port\+Info} \&a\+\_\+info, \hyperlink{classraft_1_1kernel}{raft\+::kernel} \&b, const std\+::string name\+\_\+b, \hyperlink{struct_port_info}{Port\+Info} \&b\+\_\+info)
\item 
\hypertarget{class_map_base_a4c6452a79012d0a98eb6c406e008d87e}{}\label{class_map_base_a4c6452a79012d0a98eb6c406e008d87e} 
static void {\bfseries insert} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$a, \hyperlink{struct_port_info}{Port\+Info} \&a\+\_\+out, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$b, \hyperlink{struct_port_info}{Port\+Info} \&b\+\_\+in, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$i)
\item 
{\footnotesize template$<$raft\+::order\+::spec t, typename std\+::enable\+\_\+if$<$ t==raft\+::order\+::in $>$\+::type $\ast$  = nullptr$>$ }\\static void \hyperlink{class_map_base_ab2bdd75e5f2f7a84ec7146625f85dbde}{set\+\_\+order} (\hyperlink{struct_port_info}{Port\+Info} \&port\+\_\+info\+\_\+a, \hyperlink{struct_port_info}{Port\+Info} \&port\+\_\+info\+\_\+b) noexcept
\item 
{\footnotesize template$<$raft\+::order\+::spec t, typename std\+::enable\+\_\+if$<$ t==raft\+::order\+::out $>$\+::type $\ast$  = nullptr$>$ }\\static void \hyperlink{class_map_base_ab2bdd75e5f2f7a84ec7146625f85dbde}{set\+\_\+order} (\hyperlink{struct_port_info}{Port\+Info} \&port\+\_\+info\+\_\+a, \hyperlink{struct_port_info}{Port\+Info} \&port\+\_\+info\+\_\+b) noexcept
\item 
\hypertarget{class_map_base_aceaf697d85cb24d8e62e2983980cca03}{}\label{class_map_base_aceaf697d85cb24d8e62e2983980cca03} 
static void {\bfseries port\+Not\+Found} (bool src, \hyperlink{class_port_not_found_exception}{Port\+Not\+Found\+Exception} \&ex, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const k)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
kernelkeeper \hyperlink{class_map_base_a2541cb37a237e66fc88129f9f0b02f50}{source\+\_\+kernels}
\item 
kernelkeeper \hyperlink{class_map_base_a83bb7ac6b0e80882356946d19da7ce4a}{dst\+\_\+kernels}
\item 
kernelkeeper \hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\+\_\+kernels}
\item 
std\+::vector$<$ \hyperlink{class_map_base}{Map\+Base} $\ast$$>$ \hyperlink{class_map_base_abc4856ed552e77510211851f0a4a02ab}{sub\+\_\+maps}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_map_base_aa25a3986fa3c9242f434168844d4ddfb}{}\label{class_map_base_aa25a3986fa3c9242f434168844d4ddfb} 
class {\bfseries raft\+::map}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{mapbase_8hpp_source}{mapbase.\+hpp} -\/ Base map object. The general idea is that the map object will contain everything needed to construct a streaming topology. There are two sub-\/classes. One is the final \char`\"{}map\char`\"{} topology, the other is the kernel map topology. The \char`\"{}kernel map\char`\"{} variant has no exe functions nor map checking functions. It is assumed that the \char`\"{}kernel map\char`\"{} derivative is contained within a kernel which might have several sub \char`\"{}kernels\char`\"{} within it.

\begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Fri Sep 12 10\+:28\+:33 2014
\end{DoxyVersion}
Copyright 2014 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 

Definition at line 51 of file mapbase.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_map_base_a5a923d5b3ececb0407aa934d967ab7b1}{}\label{class_map_base_a5a923d5b3ececb0407aa934d967ab7b1} 
\index{Map\+Base@{Map\+Base}!Map\+Base@{Map\+Base}}
\index{Map\+Base@{Map\+Base}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{Map\+Base()}{MapBase()}}
{\footnotesize\ttfamily Map\+Base\+::\+Map\+Base (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\hyperlink{class_map_base}{Map\+Base} -\/ constructor, really doesn\textquotesingle{}t do too much at the monent and doesn\textquotesingle{}t really need to.

\hyperlink{mapbase_8cpp_source}{mapbase.\+cpp} -\/ \begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Fri Sep 12 10\+:28\+:33 2014
\end{DoxyVersion}
Copyright 2014 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 

Definition at line 35 of file mapbase.\+cpp.


\begin{DoxyCode}
36 \{
37   
38 \}
\end{DoxyCode}
\hypertarget{class_map_base_a6c62d788746d2161264b84ba66efcfbe}{}\label{class_map_base_a6c62d788746d2161264b84ba66efcfbe} 
\index{Map\+Base@{Map\+Base}!````~Map\+Base@{$\sim$\+Map\+Base}}
\index{````~Map\+Base@{$\sim$\+Map\+Base}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{$\sim$\+Map\+Base()}{~MapBase()}}
{\footnotesize\ttfamily Map\+Base\+::$\sim$\+Map\+Base (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

default destructor 

Definition at line 40 of file mapbase.\+cpp.



References all\+\_\+kernels.


\begin{DoxyCode}
41 \{
42    \textcolor{keyword}{auto} &container( \hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\_kernels}.acquire() );
43    \textcolor{keywordflow}{for}( \hyperlink{classraft_1_1kernel}{raft::kernel} *kern : container )
44    \{
45       \textcolor{keywordflow}{if}( kern != \textcolor{keyword}{nullptr} && kern->internal\_alloc ) 
46       \{   
47          \textcolor{keywordflow}{if}( kern->internal\_alloc )
48          \{
49             \textcolor{keyword}{delete}( kern );
50          \}
51       \}
52    \}
53    \hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\_kernels}.release();
54 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{class_map_base_a2624d7b81f0078dcc78e524045403e28}{}\label{class_map_base_a2624d7b81f0078dcc78e524045403e28} 
\index{Map\+Base@{Map\+Base}!join@{join}}
\index{join@{join}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{join()}{join()}}
{\footnotesize\ttfamily void Map\+Base\+::join (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} \&}]{a,  }\item[{const std\+::string}]{name\+\_\+a,  }\item[{\hyperlink{struct_port_info}{Port\+Info} \&}]{a\+\_\+info,  }\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} \&}]{b,  }\item[{const std\+::string}]{name\+\_\+b,  }\item[{\hyperlink{struct_port_info}{Port\+Info} \&}]{b\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

join -\/ helper method joins the two ports given the correct information. Essentially the correct information for the \hyperlink{struct_port_info}{Port\+Info} object is set. Type is also checked using the typeid information. If the types aren\textquotesingle{}t the same then an exception is thrown. 
\begin{DoxyParams}{Parameters}
{\em a} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}\& \\
\hline
{\em name\+\_\+a} & -\/ name for the port on kernel a \\
\hline
{\em a\+\_\+info} & -\/ \hyperlink{struct_port_info}{Port\+Info} struct for kernel a \\
\hline
{\em b} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}\& \\
\hline
{\em name\+\_\+b} & -\/ name for port on kernel b \\
\hline
{\em b\+\_\+info} & -\/ \hyperlink{struct_port_info}{Port\+Info} struct for kernel b \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_port_type_mismatch_exception}{Port\+Type\+Mismatch\+Exception}} & \\
\hline
\end{DoxyExceptions}


Definition at line 58 of file mapbase.\+cpp.



References Port\+::get\+Port\+Info\+For(), raft\+::kernel\+::input, common\+::print\+Class\+Name(), and Port\+Info\+::type.



Referenced by raft\+::map\+::enable\+Duplication(), link(), and raft\+::map\+::operator+=().


\begin{DoxyCode}
60 \{
61    \textcolor{comment}{//b's port info isn't allocated}
62    \textcolor{keywordflow}{if}( a\_info.\hyperlink{struct_port_info_a669818f0fde1da7b4a294c46e08d5980}{type} != b\_info.\hyperlink{struct_port_info_a669818f0fde1da7b4a294c46e08d5980}{type} )
63    \{
64       std::stringstream ss;
65       ss << \textcolor{stringliteral}{"When attempting to join ports ("} << \hyperlink{classcommon_aec4b942352abd180c71fca2c0dbd70b7}{common::printClassName}( a ) <<  
66          \textcolor{stringliteral}{"["} << name\_a << \textcolor{stringliteral}{"] -> "} << \hyperlink{classcommon_aec4b942352abd180c71fca2c0dbd70b7}{common::printClassName}( b ) << \textcolor{stringliteral}{"["} << 
67          name\_b << \textcolor{stringliteral}{"] have conflicting types.  "} << 
68             common::printClassNameFromStr( a\_info.\hyperlink{struct_port_info_a669818f0fde1da7b4a294c46e08d5980}{type}.name() ) <<  
69          \textcolor{stringliteral}{" and "} << common::printClassNameFromStr( b\_info.\hyperlink{struct_port_info_a669818f0fde1da7b4a294c46e08d5980}{type}.name() ) << \textcolor{stringliteral}{"\(\backslash\)n"}; 
70       \textcolor{keywordflow}{throw} \hyperlink{class_port_type_mismatch_exception}{PortTypeMismatchException}( ss.str() );
71    \}
72 
73    a\_info.other\_kernel = &b;
74    a\_info.other\_name   = name\_b;
75    b\_info.other\_kernel = &a;
76    b\_info.other\_name   = name\_a;
77 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_map_base_a2624d7b81f0078dcc78e524045403e28_cgraph}
\end{center}
\end{figure}
\hypertarget{class_map_base_ad98ef02c1651130ad6b565ad156b97c1}{}\label{class_map_base_ad98ef02c1651130ad6b565ad156b97c1} 
\index{Map\+Base@{Map\+Base}!link@{link}}
\index{link@{link}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{link()}{link()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ \\
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} Map\+Base\+::link (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{a,  }\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{b,  }\item[{const std\+::size\+\_\+t}]{buffer = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

link -\/ this comment goes for the next 4 types of link functions, which basically do the exact same thing. The template function takes a single param order\+::spec which is exactly as the name implies, the order of the queue linking the two kernels. The various functions are needed to specify different ordering types each of these will be commented separately below. This function assumes that Kernel \textquotesingle{}a\textquotesingle{} has only a single output and \hyperlink{classraft_1_1kernel}{raft\+::kernel} \textquotesingle{}b\textquotesingle{} has only a single input otherwise an exception will be thrown. 
\begin{DoxyParams}{Parameters}
{\em a} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$, src kernel \\
\hline
{\em b} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$, dst kernel \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_ambiguous_port_assignment_exception}{Ambiguous\+Port\+Assignment\+Exception}} & -\/ thrown if either src or dst have more than a single port to link. \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} -\/ references to src, dst kernels. 
\end{DoxyReturn}


Definition at line 82 of file mapbase.\+hpp.



References Port\+::get\+Port\+Info(), raft\+::kernel\+::input, and join().



Referenced by raft\+::map\+::joink(), and display$<$ T $>$\+::run().


\begin{DoxyCode}
85    \{
86       updateKernels( a, b );
87       \hyperlink{struct_port_info}{PortInfo} *port\_info\_a;
88       \textcolor{keywordflow}{try}\{ 
89          port\_info\_a =  &(a->output.\hyperlink{class_port_a4af1cb062940ca3b83c569f024b9a8d1}{getPortInfo}());
90       \}
91       \textcolor{keywordflow}{catch}( \hyperlink{class_port_not_found_exception}{PortNotFoundException} &ex )
92       \{
93          portNotFound( \textcolor{keyword}{true},
94                        ex,
95                        a );
96       \}
97       port\_info\_a->fixed\_buffer\_size = buffer;
98       \hyperlink{struct_port_info}{PortInfo} *port\_info\_b;
99       \textcolor{keywordflow}{try}\{
100          port\_info\_b = &(b->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a4af1cb062940ca3b83c569f024b9a8d1}{getPortInfo}());
101       \}
102       \textcolor{keywordflow}{catch}( \hyperlink{class_port_not_found_exception}{PortNotFoundException} &ex )
103       \{
104             portNotFound( \textcolor{keyword}{false}, 
105                           ex,
106                           b );
107       \}
108       port\_info\_b->fixed\_buffer\_size = buffer;
109 
110       \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}( *a, port\_info\_a->my\_name, *port\_info\_a, 
111             *b, port\_info\_b->my\_name, *port\_info\_b );
112       set\_order< t >( *port\_info\_a, *port\_info\_b ); 
113       \textcolor{keywordflow}{return}( \hyperlink{classkernel__pair__t}{kernel\_pair\_t}( a, b ) );
114    \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_map_base_ad98ef02c1651130ad6b565ad156b97c1_cgraph}
\end{center}
\end{figure}
\hypertarget{class_map_base_ad982ebf61439a069ed36dc5f756b732a}{}\label{class_map_base_ad982ebf61439a069ed36dc5f756b732a} 
\index{Map\+Base@{Map\+Base}!link@{link}}
\index{link@{link}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{link()}{link()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ \\
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} Map\+Base\+::link (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{a,  }\item[{const std\+::string}]{a\+\_\+port,  }\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{b,  }\item[{const std\+::size\+\_\+t}]{buffer = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

link -\/ same as function above save for the following differences\+: kernel a is assumed to have multiple ports and the one we wish to link with \hyperlink{classraft_1_1kernel}{raft\+::kernel} b is a\+\_\+port. \hyperlink{classraft_1_1kernel}{raft\+::kernel} b is assumed to have a single input port to connect otherwise an exception is thrown. 
\begin{DoxyParams}{Parameters}
{\em a} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$a, can have multiple ports \\
\hline
{\em a\+\_\+port} & -\/ port within \hyperlink{classraft_1_1kernel}{raft\+::kernel} a to link \\
\hline
{\em b} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$b, assumed to have only single input. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_ambiguous_port_assignment_exception}{Ambiguous\+Port\+Assignment\+Exception}} & -\/ thrown if \hyperlink{classraft_1_1kernel}{raft\+::kernel} b has more than a single input port. \\
\hline
{\em \hyperlink{class_port_not_found_exception}{Port\+Not\+Found\+Exception}} & -\/ thrown if \hyperlink{classraft_1_1kernel}{raft\+::kernel} a has no port named a\+\_\+port. \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} -\/ references to src, dst kernels. 
\end{DoxyReturn}


Definition at line 131 of file mapbase.\+hpp.



References Port\+::get\+Port\+Info(), Port\+::get\+Port\+Info\+For(), raft\+::kernel\+::input, and join().


\begin{DoxyCode}
135    \{
136       updateKernels( a, b );
137       \hyperlink{struct_port_info}{PortInfo} &port\_info\_a( a->output.\hyperlink{class_port_afb426a015195fa9b4b5b1d1200daf8ed}{getPortInfoFor}( a\_port ) );
138       port\_info\_a.fixed\_buffer\_size = buffer;
139       \hyperlink{struct_port_info}{PortInfo} *port\_info\_b;
140       \textcolor{keywordflow}{try}\{
141          port\_info\_b = &(b->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a4af1cb062940ca3b83c569f024b9a8d1}{getPortInfo}());
142       \}
143       \textcolor{keywordflow}{catch}( \hyperlink{class_port_not_found_exception}{PortNotFoundException} &ex ) 
144       \{
145             portNotFound( \textcolor{keyword}{false},
146                           ex,
147                           b );
148       \}
149       port\_info\_b->fixed\_buffer\_size = buffer;
150       \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}( *a, a\_port , port\_info\_a, 
151             *b, port\_info\_b->my\_name, *port\_info\_b );
152       set\_order< t >( port\_info\_a, *port\_info\_b ); 
153       \textcolor{keywordflow}{return}( \hyperlink{classkernel__pair__t}{kernel\_pair\_t}( a, b ) );
154    \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_map_base_ad982ebf61439a069ed36dc5f756b732a_cgraph}
\end{center}
\end{figure}
\hypertarget{class_map_base_a19a0a2f6842a863327920776457c52bf}{}\label{class_map_base_a19a0a2f6842a863327920776457c52bf} 
\index{Map\+Base@{Map\+Base}!link@{link}}
\index{link@{link}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{link()}{link()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ \\
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} Map\+Base\+::link (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{a,  }\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{b,  }\item[{const std\+::string}]{b\+\_\+port,  }\item[{const std\+::size\+\_\+t}]{buffer = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

link -\/ same as above save for the following differences\+: \hyperlink{classraft_1_1kernel}{raft\+::kernel} a is assumed to have a single output port. \hyperlink{classraft_1_1kernel}{raft\+::kernel} b is assumed to have more than one input port, within one matching the port b\+\_\+port. 
\begin{DoxyParams}{Parameters}
{\em a} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$, with more a single output port \\
\hline
{\em b} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$, with input port named b\+\_\+port \\
\hline
{\em b\+\_\+port} & -\/ const std\+::string, input port name. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_ambiguous_port_assignment_exception}{Ambiguous\+Port\+Assignment\+Exception}} & -\/ exception thrown if \hyperlink{classraft_1_1kernel}{raft\+::kernel} a has more than a single output port \\
\hline
{\em \hyperlink{class_port_not_found_exception}{Port\+Not\+Found\+Exception}} & -\/ exception thrown if \hyperlink{classraft_1_1kernel}{raft\+::kernel} b has no input port named b\+\_\+port \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} -\/ references to src, dst kernels. 
\end{DoxyReturn}


Definition at line 172 of file mapbase.\+hpp.



References Port\+::get\+Port\+Info(), Port\+::get\+Port\+Info\+For(), raft\+::kernel\+::input, and join().


\begin{DoxyCode}
176    \{
177       updateKernels( a, b );
178       \hyperlink{struct_port_info}{PortInfo} *port\_info\_a;
179       \textcolor{keywordflow}{try}\{
180          port\_info\_a = &(a->output.\hyperlink{class_port_a4af1cb062940ca3b83c569f024b9a8d1}{getPortInfo}() );
181       \}
182       \textcolor{keywordflow}{catch}( \hyperlink{class_port_not_found_exception}{PortNotFoundException} &ex ) 
183       \{
184             portNotFound( \textcolor{keyword}{true},
185                           ex,
186                           a );
187       \}
188       port\_info\_a->fixed\_buffer\_size = buffer;
189       
190       \hyperlink{struct_port_info}{PortInfo} &port\_info\_b( b->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_afb426a015195fa9b4b5b1d1200daf8ed}{getPortInfoFor}( b\_port) );
191       port\_info\_b.fixed\_buffer\_size = buffer;
192       
193       \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}( *a, port\_info\_a->my\_name, *port\_info\_a, 
194             *b, b\_port, port\_info\_b );
195       set\_order< t >( *port\_info\_a, port\_info\_b ); 
196       \textcolor{keywordflow}{return}( \hyperlink{classkernel__pair__t}{kernel\_pair\_t}( a, b ) );
197    \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_map_base_a19a0a2f6842a863327920776457c52bf_cgraph}
\end{center}
\end{figure}
\hypertarget{class_map_base_af06481b99a96e3c5ae8da88cc8a78e91}{}\label{class_map_base_af06481b99a96e3c5ae8da88cc8a78e91} 
\index{Map\+Base@{Map\+Base}!link@{link}}
\index{link@{link}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{link()}{link()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$raft\+::order\+::spec t = raft\+::order\+::in$>$ \\
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} Map\+Base\+::link (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{a,  }\item[{const std\+::string}]{a\+\_\+port,  }\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{b,  }\item[{const std\+::string}]{b\+\_\+port,  }\item[{const std\+::size\+\_\+t}]{buffer = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

link -\/ same as above save for the following differences\+: \hyperlink{classraft_1_1kernel}{raft\+::kernel} a is assumed to have an output port a\+\_\+port and \hyperlink{classraft_1_1kernel}{raft\+::kernel} b is assumed to have an input port b\+\_\+port. 
\begin{DoxyParams}{Parameters}
{\em a} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$, with more a single output port \\
\hline
{\em a\+\_\+port} & -\/ const std\+::string, output port name \\
\hline
{\em b} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$, with input port named b\+\_\+port \\
\hline
{\em b\+\_\+port} & -\/ const std\+::string, input port name. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_port_not_found_exception}{Port\+Not\+Found\+Exception}} & -\/ exception thrown if either kernel is missing port a\+\_\+port or b\+\_\+port. \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
\hyperlink{classkernel__pair__t}{kernel\+\_\+pair\+\_\+t} -\/ references to src, dst kernels. 
\end{DoxyReturn}


Definition at line 212 of file mapbase.\+hpp.



References Port\+::get\+Port\+Info\+For(), raft\+::kernel\+::input, and join().


\begin{DoxyCode}
217    \{
218       updateKernels( a, b );
219       \textcolor{keyword}{auto} &port\_info\_a( a->output.\hyperlink{class_port_afb426a015195fa9b4b5b1d1200daf8ed}{getPortInfoFor}( a\_port ) );
220       port\_info\_a.fixed\_buffer\_size = buffer;
221       \textcolor{keyword}{auto} &port\_info\_b( b->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_afb426a015195fa9b4b5b1d1200daf8ed}{getPortInfoFor}( b\_port) );
222       port\_info\_b.fixed\_buffer\_size = buffer;
223       
224       \hyperlink{class_map_base_a2624d7b81f0078dcc78e524045403e28}{join}( *a, a\_port, port\_info\_a, 
225             *b, b\_port, port\_info\_b );
226       set\_order< t >( port\_info\_a, port\_info\_b ); 
227       \textcolor{keywordflow}{return}( \hyperlink{classkernel__pair__t}{kernel\_pair\_t}( a, b ) );
228    \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_map_base_af06481b99a96e3c5ae8da88cc8a78e91_cgraph}
\end{center}
\end{figure}
\hypertarget{class_map_base_ab2bdd75e5f2f7a84ec7146625f85dbde}{}\label{class_map_base_ab2bdd75e5f2f7a84ec7146625f85dbde} 
\index{Map\+Base@{Map\+Base}!set\+\_\+order@{set\+\_\+order}}
\index{set\+\_\+order@{set\+\_\+order}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{set\+\_\+order()}{set\_order()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$raft\+::order\+::spec t, typename std\+::enable\+\_\+if$<$ t==raft\+::order\+::in $>$\+::type $\ast$  = nullptr$>$ \\
static void Map\+Base\+::set\+\_\+order (\begin{DoxyParamCaption}\item[{\hyperlink{struct_port_info}{Port\+Info} \&}]{port\+\_\+info\+\_\+a,  }\item[{\hyperlink{struct_port_info}{Port\+Info} \&}]{port\+\_\+info\+\_\+b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}

set\+\_\+order -\/ keep redundant code, well, less redundant. This version handles the in-\/order settings. 
\begin{DoxyParams}{Parameters}
{\em port\+\_\+info\+\_\+a,Port\+Info\&} & \\
\hline
{\em port\+\_\+info\+\_\+b,Port\+Info\&} & \\
\hline
\end{DoxyParams}


Definition at line 264 of file mapbase.\+hpp.


\begin{DoxyCode}
266    \{
267         port\_info\_a.out\_of\_order = \textcolor{keyword}{false}; 
268         port\_info\_b.out\_of\_order = \textcolor{keyword}{false};
269         \textcolor{keywordflow}{return};           
270    \}
\end{DoxyCode}
\hypertarget{class_map_base_ab2bdd75e5f2f7a84ec7146625f85dbde}{}\label{class_map_base_ab2bdd75e5f2f7a84ec7146625f85dbde} 
\index{Map\+Base@{Map\+Base}!set\+\_\+order@{set\+\_\+order}}
\index{set\+\_\+order@{set\+\_\+order}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{set\+\_\+order()}{set\_order()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$raft\+::order\+::spec t, typename std\+::enable\+\_\+if$<$ t==raft\+::order\+::out $>$\+::type $\ast$  = nullptr$>$ \\
static void Map\+Base\+::set\+\_\+order (\begin{DoxyParamCaption}\item[{\hyperlink{struct_port_info}{Port\+Info} \&}]{port\+\_\+info\+\_\+a,  }\item[{\hyperlink{struct_port_info}{Port\+Info} \&}]{port\+\_\+info\+\_\+b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}

set\+\_\+order -\/ keep redundant code, well, less redundant. This version handles the out-\/of-\/order settings. 
\begin{DoxyParams}{Parameters}
{\em port\+\_\+info\+\_\+a,Port\+Info\&} & \\
\hline
{\em port\+\_\+info\+\_\+b,Port\+Info\&} & \\
\hline
\end{DoxyParams}


Definition at line 281 of file mapbase.\+hpp.



References all\+\_\+kernels, dst\+\_\+kernels, and source\+\_\+kernels.


\begin{DoxyCode}
283    \{
284         port\_info\_a.out\_of\_order = \textcolor{keyword}{true}; 
285         port\_info\_b.out\_of\_order = \textcolor{keyword}{true}; 
286         \textcolor{keywordflow}{return};
287    \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{}\label{class_map_base_a2220cd630c5d00708f08d9bc70a48220} 
\index{Map\+Base@{Map\+Base}!all\+\_\+kernels@{all\+\_\+kernels}}
\index{all\+\_\+kernels@{all\+\_\+kernels}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{all\+\_\+kernels}{all\_kernels}}
{\footnotesize\ttfamily kernelkeeper Map\+Base\+::all\+\_\+kernels\hspace{0.3cm}{\ttfamily [protected]}}

and keep a list of all kernels 

Definition at line 332 of file mapbase.\+hpp.



Referenced by raft\+::map\+::exe(), set\+\_\+order(), and $\sim$\+Map\+Base().

\hypertarget{class_map_base_a83bb7ac6b0e80882356946d19da7ce4a}{}\label{class_map_base_a83bb7ac6b0e80882356946d19da7ce4a} 
\index{Map\+Base@{Map\+Base}!dst\+\_\+kernels@{dst\+\_\+kernels}}
\index{dst\+\_\+kernels@{dst\+\_\+kernels}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{dst\+\_\+kernels}{dst\_kernels}}
{\footnotesize\ttfamily kernelkeeper Map\+Base\+::dst\+\_\+kernels\hspace{0.3cm}{\ttfamily [protected]}}

dst kernels 

Definition at line 330 of file mapbase.\+hpp.



Referenced by set\+\_\+order().

\hypertarget{class_map_base_a2541cb37a237e66fc88129f9f0b02f50}{}\label{class_map_base_a2541cb37a237e66fc88129f9f0b02f50} 
\index{Map\+Base@{Map\+Base}!source\+\_\+kernels@{source\+\_\+kernels}}
\index{source\+\_\+kernels@{source\+\_\+kernels}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{source\+\_\+kernels}{source\_kernels}}
{\footnotesize\ttfamily kernelkeeper Map\+Base\+::source\+\_\+kernels\hspace{0.3cm}{\ttfamily [protected]}}

need to keep source kernels 

Definition at line 328 of file mapbase.\+hpp.



Referenced by raft\+::map\+::exe(), and set\+\_\+order().

\hypertarget{class_map_base_abc4856ed552e77510211851f0a4a02ab}{}\label{class_map_base_abc4856ed552e77510211851f0a4a02ab} 
\index{Map\+Base@{Map\+Base}!sub\+\_\+maps@{sub\+\_\+maps}}
\index{sub\+\_\+maps@{sub\+\_\+maps}!Map\+Base@{Map\+Base}}
\subsubsection{\texorpdfstring{sub\+\_\+maps}{sub\_maps}}
{\footnotesize\ttfamily std\+::vector$<$ \hyperlink{class_map_base}{Map\+Base}$\ast$ $>$ Map\+Base\+::sub\+\_\+maps\hspace{0.3cm}{\ttfamily [protected]}}

F\+I\+X\+ME\+: come up with better solution for enabling online duplication of submaps as a unit.

D\+O\+ES\+: flatten these kernels into main map once we run 

Definition at line 339 of file mapbase.\+hpp.



Referenced by raft\+::map\+::exe().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
mapbase.\+hpp\item 
mapbase.\+cpp\end{DoxyCompactItemize}
