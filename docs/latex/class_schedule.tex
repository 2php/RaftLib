\hypertarget{class_schedule}{}\section{Schedule Class Reference}
\label{class_schedule}\index{Schedule@{Schedule}}


Inheritance diagram for Schedule\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=268pt]{class_schedule__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Schedule\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=294pt]{class_schedule__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_schedule_ae3fcf18fa8bdbe2ac438962a324cf433}{Schedule} (\hyperlink{classraft_1_1map}{raft\+::map} \&map)
\item 
virtual \hyperlink{class_schedule_a68e52c571576866ef55cb4e891232c58}{$\sim$\+Schedule} ()=default
\item 
virtual void \hyperlink{class_schedule_ab6ad5540ecdef6b472b4e8242a47c4ee}{start} ()=0
\item 
virtual void \hyperlink{class_schedule_a5180032a0c2135507859ccf2a4eea1ab}{init} ()
\item 
virtual void \hyperlink{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641}{schedule\+Kernel} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{class_schedule_acf28b4a4231e693585751a035873615c}{kernel\+Run} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel, volatile bool \&finished, jmp\+\_\+buf $\ast$gotostate=nullptr, jmp\+\_\+buf $\ast$kernel\+\_\+state=nullptr)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_schedule_addff3f2e72caab274963cc888faa2f6b}{}\label{class_schedule_addff3f2e72caab274963cc888faa2f6b} 
virtual void {\bfseries handle\+Schedule} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel)=0
\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static raft\+::kstatus \hyperlink{class_schedule_a85de3d48407aa378ccc86a4a4206b32a}{check\+System\+Signal} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel, void $\ast$data, \hyperlink{class_system_signal_handler}{System\+Signal\+Handler} \&\hyperlink{class_schedule_ad248e99611a87776fb411836cd46a603}{handlers})
\item 
static raft\+::kstatus \hyperlink{class_schedule_a5167d622689a34ea5f3a065304295521}{quit\+Handler} (\hyperlink{class_f_i_f_o}{F\+I\+FO} \&fifo, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel, const raft\+::signal signal, void $\ast$data)
\item 
\hypertarget{class_schedule_a3bf10fd9419c58849d7be98336dc0aff}{}\label{class_schedule_a3bf10fd9419c58849d7be98336dc0aff} 
static void {\bfseries invalidate\+Output\+Ports} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel)
\item 
static bool \hyperlink{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{kernel\+Has\+Input\+Data} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel)
\item 
static bool \hyperlink{class_schedule_a2e2035e0c0666054f8401ad2b3792854}{kernel\+Has\+No\+Input\+Ports} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel)
\item 
static void \hyperlink{class_schedule_aefaf185cc7d1f424cef7b23d8f679d47}{set\+Ptr\+Sets} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel, ptr\+\_\+map\+\_\+t $\ast$const in, ptr\+\_\+set\+\_\+t $\ast$const out, ptr\+\_\+set\+\_\+t $\ast$const peekset)
\item 
\hypertarget{class_schedule_a64d4c026c95da079a92d2a3790bb5279}{}\label{class_schedule_a64d4c026c95da079a92d2a3790bb5279} 
static void {\bfseries fifo\+\_\+gc} (ptr\+\_\+map\+\_\+t $\ast$const in, ptr\+\_\+set\+\_\+t $\ast$const out, ptr\+\_\+set\+\_\+t $\ast$const peekset)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_system_signal_handler}{System\+Signal\+Handler} \hyperlink{class_schedule_ad248e99611a87776fb411836cd46a603}{handlers}
\item 
kernelkeeper \& \hyperlink{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}{kernel\+\_\+set}
\item 
\hypertarget{class_schedule_ad4c895eb77d8287a9a19215cced7af7b}{}\label{class_schedule_ad4c895eb77d8287a9a19215cced7af7b} 
kernelkeeper \& {\bfseries source\+\_\+kernels}
\item 
\hypertarget{class_schedule_aebf2c26334eae760032d82a016898043}{}\label{class_schedule_aebf2c26334eae760032d82a016898043} 
kernelkeeper \& {\bfseries dst\+\_\+kernels}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 35 of file schedule.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_schedule_ae3fcf18fa8bdbe2ac438962a324cf433}{}\label{class_schedule_ae3fcf18fa8bdbe2ac438962a324cf433} 
\index{Schedule@{Schedule}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{Schedule()}{Schedule()}}
{\footnotesize\ttfamily Schedule\+::\+Schedule (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1map}{raft\+::map} \&}]{map }\end{DoxyParamCaption})}

\hyperlink{class_schedule}{Schedule} -\/ base constructor takes a map object so that all sub-\/classes can access some of the map features through the schedule sub-\/class accessors. 
\begin{DoxyParams}{Parameters}
{\em map} & -\/ Map\& \\
\hline
\end{DoxyParams}


Definition at line 10 of file schedule.\+cpp.



References System\+Signal\+Handler\+::add\+Handler(), handlers, and quit\+Handler().


\begin{DoxyCode}
10                                  : \hyperlink{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}{kernel\_set}( map.\hyperlink{class_map_base_a2220cd630c5d00708f08d9bc70a48220}{all\_kernels} ),
11                                  source\_kernels( map.\hyperlink{class_map_base_a2541cb37a237e66fc88129f9f0b02f50}{source\_kernels} ),
12                                  dst\_kernels( map.\hyperlink{class_map_base_a83bb7ac6b0e80882356946d19da7ce4a}{dst\_kernels} )
13 \{
14    \textcolor{comment}{//TODO, see if we want to keep this}
15    \hyperlink{class_schedule_ad248e99611a87776fb411836cd46a603}{handlers}.\hyperlink{class_system_signal_handler_a50e022b8b70b7168a20e3ae91c158c70}{addHandler}( raft::quit, \hyperlink{class_schedule_a5167d622689a34ea5f3a065304295521}{Schedule::quitHandler} );
16 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_schedule_ae3fcf18fa8bdbe2ac438962a324cf433_cgraph}
\end{center}
\end{figure}
\hypertarget{class_schedule_a68e52c571576866ef55cb4e891232c58}{}\label{class_schedule_a68e52c571576866ef55cb4e891232c58} 
\index{Schedule@{Schedule}!````~Schedule@{$\sim$\+Schedule}}
\index{````~Schedule@{$\sim$\+Schedule}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{$\sim$\+Schedule()}{~Schedule()}}
{\footnotesize\ttfamily virtual Schedule\+::$\sim$\+Schedule (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}

destructor, takes care of cleanup 

\subsection{Member Function Documentation}
\hypertarget{class_schedule_a85de3d48407aa378ccc86a4a4206b32a}{}\label{class_schedule_a85de3d48407aa378ccc86a4a4206b32a} 
\index{Schedule@{Schedule}!check\+System\+Signal@{check\+System\+Signal}}
\index{check\+System\+Signal@{check\+System\+Signal}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{check\+System\+Signal()}{checkSystemSignal()}}
{\footnotesize\ttfamily raft\+::kstatus Schedule\+::check\+System\+Signal (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const}]{kernel,  }\item[{void $\ast$}]{data,  }\item[{\hyperlink{class_system_signal_handler}{System\+Signal\+Handler} \&}]{handlers }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

check\+System\+Signal -\/ check the incomming streams for the param kernel for any system signals, if there is one then consume the signal and perform the appropriate action. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} \\
\hline
{\em data} & -\/ void$\ast$, use this if any further info is needed in future implementations of handlers \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
raft\+::kstatus, proceed unless a stop signal is received 
\end{DoxyReturn}
T\+O\+DO, right now there is special behavior for term signal only, what should we do with others? Need to decide that.

Definition at line 58 of file schedule.\+cpp.



References System\+Signal\+Handler\+::call\+Handler(), and raft\+::kernel\+::input.


\begin{DoxyCode}
61 \{
62    \textcolor{keyword}{auto} &input\_ports( kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input} );
63    raft::kstatus ret\_signal( raft::proceed );
64    \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} &port : input\_ports )
65    \{
66       \textcolor{keywordflow}{if}( port.size() == 0 )
67       \{
68          \textcolor{keywordflow}{continue};
69       \}
70       \textcolor{keyword}{const} \textcolor{keyword}{auto} curr\_signal( port.signal\_peek() );
71       \textcolor{keywordflow}{if}( R\_UNLIKELY(
72          ( curr\_signal > 0 && curr\_signal < raft::MAX\_SYSTEM\_SIGNAL ) ) )
73       \{
74          port.signal\_pop();\textcolor{comment}{}
75 \textcolor{comment}{         /**}
76 \textcolor{comment}{          * TODO, right now there is special behavior for term signal only,}
77 \textcolor{comment}{          * what should we do with others?  Need to decide that.}
78 \textcolor{comment}{          */}
79 
80          \textcolor{keywordflow}{if}( handlers.\hyperlink{class_system_signal_handler_ac66db8af116e4f887706e58acb0781bb}{callHandler}( curr\_signal,
81                                port,
82                                kernel,
83                                data ) == raft::stop )
84          \{
85             ret\_signal = raft::stop;
86          \}
87       \}
88    \}
89    \textcolor{keywordflow}{return}( ret\_signal );
90 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_schedule_a85de3d48407aa378ccc86a4a4206b32a_cgraph}
\end{center}
\end{figure}
\hypertarget{class_schedule_a5180032a0c2135507859ccf2a4eea1ab}{}\label{class_schedule_a5180032a0c2135507859ccf2a4eea1ab} 
\index{Schedule@{Schedule}!init@{init}}
\index{init@{init}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void Schedule\+::init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

init -\/ call to pre-\/process all kernels, this function is called by the map object befure calling start. default, do nothing 

Definition at line 20 of file schedule.\+cpp.


\begin{DoxyCode}
21 \{\textcolor{comment}{}
22 \textcolor{comment}{   /** default, do nothing **/}
23 \}
\end{DoxyCode}
\hypertarget{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{}\label{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa} 
\index{Schedule@{Schedule}!kernel\+Has\+Input\+Data@{kernel\+Has\+Input\+Data}}
\index{kernel\+Has\+Input\+Data@{kernel\+Has\+Input\+Data}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{kernel\+Has\+Input\+Data()}{kernelHasInputData()}}
{\footnotesize\ttfamily bool Schedule\+::kernel\+Has\+Input\+Data (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

kernel\+Has\+Input\+Data -\/ check each input port for available data, returns true if any of the input ports has available data. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool -\/ true if input data available. 
\end{DoxyReturn}
only output ports, keep calling till exits 

Definition at line 120 of file schedule.\+cpp.



References raft\+::kernel\+::input.



Referenced by kernel\+Run().


\begin{DoxyCode}
121 \{
122    \textcolor{keyword}{auto} &port\_list( kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input} );
123    \textcolor{keywordflow}{if}( ! port\_list.hasPorts() )
124    \{\textcolor{comment}{}
125 \textcolor{comment}{      /** only output ports, keep calling till exits **/}
126       \textcolor{keywordflow}{return}( \textcolor{keyword}{true} );
127    \}
128    \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} &port : port\_list )
129    \{
130       \textcolor{keyword}{const} \textcolor{keyword}{auto} size( port.size() );
131       \textcolor{keywordflow}{if}( size > 0 )
132       \{
133          \textcolor{keywordflow}{return}( \textcolor{keyword}{true} );
134       \}
135    \}
136    \textcolor{keywordflow}{return}( \textcolor{keyword}{false} );
137 \}
\end{DoxyCode}
\hypertarget{class_schedule_a2e2035e0c0666054f8401ad2b3792854}{}\label{class_schedule_a2e2035e0c0666054f8401ad2b3792854} 
\index{Schedule@{Schedule}!kernel\+Has\+No\+Input\+Ports@{kernel\+Has\+No\+Input\+Ports}}
\index{kernel\+Has\+No\+Input\+Ports@{kernel\+Has\+No\+Input\+Ports}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{kernel\+Has\+No\+Input\+Ports()}{kernelHasNoInputPorts()}}
{\footnotesize\ttfamily bool Schedule\+::kernel\+Has\+No\+Input\+Ports (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

kernel\+Has\+No\+Input\+Ports -\/ pretty much exactly like the function name says, if the param kernel has no valid input ports (this function assumes that \hyperlink{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{kernel\+Has\+Input\+Data()} has been called and returns false before this function is called) then it returns true.  kernel -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \begin{DoxyReturn}{Returns}
bool -\/ true if no valid input ports avail 
\end{DoxyReturn}
assume data check is already complete 

Definition at line 142 of file schedule.\+cpp.



References raft\+::kernel\+::input.



Referenced by kernel\+Run().


\begin{DoxyCode}
143 \{
144    \textcolor{keyword}{auto} &port\_list( kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input} );\textcolor{comment}{}
145 \textcolor{comment}{   /** assume data check is already complete **/}
146    \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} &port : port\_list )
147    \{
148       \textcolor{keywordflow}{if}( ! port.is\_invalid() )
149       \{
150          \textcolor{keywordflow}{return}( \textcolor{keyword}{false} );
151       \}
152    \}
153    \textcolor{keywordflow}{return}( \textcolor{keyword}{true} );
154 \}
\end{DoxyCode}
\hypertarget{class_schedule_acf28b4a4231e693585751a035873615c}{}\label{class_schedule_acf28b4a4231e693585751a035873615c} 
\index{Schedule@{Schedule}!kernel\+Run@{kernel\+Run}}
\index{kernel\+Run@{kernel\+Run}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{kernel\+Run()}{kernelRun()}}
{\footnotesize\ttfamily bool Schedule\+::kernel\+Run (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const}]{kernel,  }\item[{volatile bool \&}]{finished,  }\item[{jmp\+\_\+buf $\ast$}]{gotostate = {\ttfamily nullptr},  }\item[{jmp\+\_\+buf $\ast$}]{kernel\+\_\+state = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

kernel\+Run -\/ all the logic necessary to run a single kernel successfully. Any additional signal handling should be handled by this function as its the only one that will be universally called by the scheduler. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const object, non-\/null kernel \\
\hline
{\em finished} & -\/ volatile bool -\/ function sets to true when done. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if run with no need for jmp\+\_\+buf, false if the scheduler needs to run again with the kernel\+\_\+state 
\end{DoxyReturn}
must recheck data items again after port valid check, there could have been a push between these two conditional statements.

Definition at line 158 of file schedule.\+cpp.



References kernel\+Has\+Input\+Data(), kernel\+Has\+No\+Input\+Ports(), and raft\+::kernel\+::run().



Referenced by kernel\+\_\+container\+::container\+\_\+run(), and simple\+\_\+schedule\+::simple\+\_\+run().


\begin{DoxyCode}
162 \{
163    UNUSED( gotostate );
164    UNUSED( kernel\_state );
165    \textcolor{keywordflow}{if}( \hyperlink{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{kernelHasInputData}( kernel ) )
166    \{
167       \textcolor{keyword}{const} \textcolor{keyword}{auto} sig\_status( kernel->\hyperlink{classraft_1_1kernel_a05094286d7577360fb1b91c91fc05901}{run}() );
168       \textcolor{keywordflow}{if}( sig\_status == raft::stop )
169       \{
170          invalidateOutputPorts( kernel );
171          finished = \textcolor{keyword}{true};
172       \}
173    \}\textcolor{comment}{}
174 \textcolor{comment}{   /**}
175 \textcolor{comment}{    * must recheck data items again after port valid check, there could}
176 \textcolor{comment}{    * have been a push between these two conditional statements.}
177 \textcolor{comment}{    */}
178    \textcolor{keywordflow}{if}(  \hyperlink{class_schedule_a2e2035e0c0666054f8401ad2b3792854}{kernelHasNoInputPorts}( kernel ) && ! 
      \hyperlink{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{kernelHasInputData}( kernel ) )
179    \{
180       invalidateOutputPorts( kernel );
181       finished = \textcolor{keyword}{true};
182    \}
183    \textcolor{keywordflow}{return}( \textcolor{keyword}{true} );
184 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_schedule_acf28b4a4231e693585751a035873615c_cgraph}
\end{center}
\end{figure}
\hypertarget{class_schedule_a5167d622689a34ea5f3a065304295521}{}\label{class_schedule_a5167d622689a34ea5f3a065304295521} 
\index{Schedule@{Schedule}!quit\+Handler@{quit\+Handler}}
\index{quit\+Handler@{quit\+Handler}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{quit\+Handler()}{quitHandler()}}
{\footnotesize\ttfamily raft\+::kstatus Schedule\+::quit\+Handler (\begin{DoxyParamCaption}\item[{\hyperlink{class_f_i_f_o}{F\+I\+FO} \&}]{fifo,  }\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$}]{kernel,  }\item[{const raft\+::signal}]{signal,  }\item[{void $\ast$}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

quite\+Handler -\/ performs the actions needed when a port sends a quite signal (normal termination), this is most likely due to the end of data. 
\begin{DoxyParams}{Parameters}
{\em fifo} & -\/ \hyperlink{class_f_i_f_o}{F\+I\+FO}\& that sent the signal \\
\hline
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \\
\hline
{\em signal} & -\/ raft\+::signal \\
\hline
{\em data} & -\/ void$\ast$, vain attempt to future proof \\
\hline
\end{DoxyParams}
N\+O\+TE\+: This should be the only action needed currently, however that may change in the futre with more features and systems added.

Definition at line 27 of file schedule.\+cpp.



References F\+I\+F\+O\+::invalidate().



Referenced by Schedule().


\begin{DoxyCode}
31 \{\textcolor{comment}{}
32 \textcolor{comment}{   /**}
33 \textcolor{comment}{    * NOTE: This should be the only action needed}
34 \textcolor{comment}{    * currently, however that may change in the futre}
35 \textcolor{comment}{    * with more features and systems added.}
36 \textcolor{comment}{    */}
37    UNUSED( kernel );
38    UNUSED( signal );
39    UNUSED( data   );
40 
41    fifo.\hyperlink{class_f_i_f_o_af65e8231c0d1a7cdf250f2ce57f3723f}{invalidate}();
42    \textcolor{keywordflow}{return}( raft::stop );
43 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=317pt]{class_schedule_a5167d622689a34ea5f3a065304295521_cgraph}
\end{center}
\end{figure}
\hypertarget{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641}{}\label{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641} 
\index{Schedule@{Schedule}!schedule\+Kernel@{schedule\+Kernel}}
\index{schedule\+Kernel@{schedule\+Kernel}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{schedule\+Kernel()}{scheduleKernel()}}
{\footnotesize\ttfamily void Schedule\+::schedule\+Kernel (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

schedule\+Kernel -\/ adds the kernel \char`\"{}kernel\char`\"{} to the schedule, ensures that it is run. Other than that there are no guarantees for its execution. The base version should do for most, however feel free to re-\/implement in derived class as long as the source\+\_\+kernels has all of the source kernels, dst\+\_\+kernels has all of the destination kernels, and kernel\+\_\+set has all of the kernels. Before you drop in a kernel, it better be ready to go..all allocations should be complete. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \\
\hline
\end{DoxyParams}
N\+O\+TE\+: The kernel param should be ready to rock, we just need to add it here. The data structures xx\+\_\+kernels all expect a fully ready kernel, well the threads monitoring the system do at least and this is one. What we need to do to kick off the execution is add it to the handle\+Schedule virtual function which is implemented by each scheduler.

Definition at line 93 of file schedule.\+cpp.



References Port\+::has\+Ports(), raft\+::kernel\+::input, and kernel\+\_\+set.



Referenced by basic\+\_\+parallel\+::start().


\begin{DoxyCode}
94 \{\textcolor{comment}{}
95 \textcolor{comment}{   /**}
96 \textcolor{comment}{    * NOTE: The kernel param should be ready to rock,}
97 \textcolor{comment}{    * we just need to add it here.  The data structures}
98 \textcolor{comment}{    * xx\_kernels all expect a fully ready kernel, well}
99 \textcolor{comment}{    * the threads monitoring the system do at least and}
100 \textcolor{comment}{    * this is one.  What we need to do to kick off the}
101 \textcolor{comment}{    * execution is add it to the handleSchedule virtual}
102 \textcolor{comment}{    * function which is implemented by each scheduler.}
103 \textcolor{comment}{    */}
104    assert( kernel != \textcolor{keyword}{nullptr} );
105    \textcolor{keywordflow}{if}( ! kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input}.\hyperlink{class_port_a7042f5b5c2ab14c9591a4984811a6012}{hasPorts}() )
106    \{
107       source\_kernels +=  kernel;
108    \}
109    \textcolor{keywordflow}{if}( ! kernel->output.\hyperlink{class_port_a7042f5b5c2ab14c9591a4984811a6012}{hasPorts}() )
110    \{
111       dst\_kernels += kernel;
112    \}
113    \hyperlink{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}{kernel\_set} += kernel;
114    handleSchedule( kernel );
115    \textcolor{keywordflow}{return};
116 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641_cgraph}
\end{center}
\end{figure}
\hypertarget{class_schedule_aefaf185cc7d1f424cef7b23d8f679d47}{}\label{class_schedule_aefaf185cc7d1f424cef7b23d8f679d47} 
\index{Schedule@{Schedule}!set\+Ptr\+Sets@{set\+Ptr\+Sets}}
\index{set\+Ptr\+Sets@{set\+Ptr\+Sets}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{set\+Ptr\+Sets()}{setPtrSets()}}
{\footnotesize\ttfamily void Schedule\+::set\+Ptr\+Sets (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const}]{kernel,  }\item[{ptr\+\_\+map\+\_\+t $\ast$const}]{in,  }\item[{ptr\+\_\+set\+\_\+t $\ast$const}]{out,  }\item[{ptr\+\_\+set\+\_\+t $\ast$const}]{peekset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

set\+Ptr\+Sets -\/ add the tracking object from the sub-\/class to track input/output ptrs in flight by the kernel. The structure will be the same across all in and output F\+I\+F\+Os, since from within a \char`\"{}kernel\char`\"{} each fifo is accessed with sequential consistency we won\textquotesingle{}t need any fancy locking structures. on each kernel firing, these structures should be checked to see if any allocated objects (the only ones to be put in these sets, need to be \char`\"{}garbage
collected\char`\"{} 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ the one we\textquotesingle{}re registering \\
\hline
{\em in} & -\/ set\+\_\+t$\ast$, the input set \\
\hline
{\em out} & -\/ set\+\_\+t$\ast$, the output set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
looks a bit odd initially, but the same peekset is set for each kernel\textquotesingle{}s \hyperlink{class_f_i_f_o}{F\+I\+FO}\textquotesingle{}s within the view of the kernel they\textquotesingle{}ll be accessed sequentially so no contention

Definition at line 187 of file schedule.\+cpp.



References raft\+::kernel\+::input.



Referenced by simple\+\_\+schedule\+::simple\+\_\+run().


\begin{DoxyCode}
191 \{
192     assert( in  != \textcolor{keyword}{nullptr} );
193     assert( out != \textcolor{keyword}{nullptr} );
194     assert( peekset != \textcolor{keyword}{nullptr} );\textcolor{comment}{}
195 \textcolor{comment}{    /**}
196 \textcolor{comment}{     * looks a bit odd initially, but the same}
197 \textcolor{comment}{     * peekset is set for each kernel's FIFO's}
198 \textcolor{comment}{     * within the view of the kernel they'll be}
199 \textcolor{comment}{     * accessed sequentially so no contention}
200 \textcolor{comment}{     */}
201     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} &port : kernel->\hyperlink{classraft_1_1kernel_a6edbe35a56409d402e719b3ac36d6554}{input} )
202     \{
203         port.setPtrMap( in );
204         port.setInPeekSet( peekset );
205     \}
206     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} &port : kernel->output )
207     \{
208         port.setPtrSet( out );
209         port.setOutPeekSet( peekset );
210     \}
211     \textcolor{keywordflow}{return};
212 \}
\end{DoxyCode}
\hypertarget{class_schedule_ab6ad5540ecdef6b472b4e8242a47c4ee}{}\label{class_schedule_ab6ad5540ecdef6b472b4e8242a47c4ee} 
\index{Schedule@{Schedule}!start@{start}}
\index{start@{start}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{start()}{start()}}
{\footnotesize\ttfamily virtual void Schedule\+::start (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

start -\/ called to start execution of all kernels. Implementation specific so it is purely virtual. 

Implemented in \hyperlink{classpool__schedule_a9dd6194fd47fd0b12d2b62dcc57e38c2}{pool\+\_\+schedule}, and \hyperlink{classsimple__schedule_ad60a7608111e011d0c04f6ac566cfd8c}{simple\+\_\+schedule}.



\subsection{Member Data Documentation}
\hypertarget{class_schedule_ad248e99611a87776fb411836cd46a603}{}\label{class_schedule_ad248e99611a87776fb411836cd46a603} 
\index{Schedule@{Schedule}!handlers@{handlers}}
\index{handlers@{handlers}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{handlers}{handlers}}
{\footnotesize\ttfamily \hyperlink{class_system_signal_handler}{System\+Signal\+Handler} Schedule\+::handlers\hspace{0.3cm}{\ttfamily [protected]}}

signal handlers 

Definition at line 179 of file schedule.\+hpp.



Referenced by Schedule().

\hypertarget{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}{}\label{class_schedule_a1a448b0d48e656f94db65a70cedd8eed} 
\index{Schedule@{Schedule}!kernel\+\_\+set@{kernel\+\_\+set}}
\index{kernel\+\_\+set@{kernel\+\_\+set}!Schedule@{Schedule}}
\subsubsection{\texorpdfstring{kernel\+\_\+set}{kernel\_set}}
{\footnotesize\ttfamily kernelkeeper\& Schedule\+::kernel\+\_\+set\hspace{0.3cm}{\ttfamily [protected]}}

kernel set 

Definition at line 182 of file schedule.\+hpp.



Referenced by schedule\+Kernel(), and simple\+\_\+schedule\+::start().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
schedule.\+hpp\item 
schedule.\+cpp\end{DoxyCompactItemize}
