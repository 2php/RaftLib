\hypertarget{class_f_i_f_o}{}\section{F\+I\+FO Class Reference}
\label{class_f_i_f_o}\index{F\+I\+FO@{F\+I\+FO}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_f_i_f_o_a200f4cf6db6b1994331ee4e0b2a594b1}{F\+I\+FO} ()=default
\item 
virtual \hyperlink{class_f_i_f_o_a75da1c02fbe46eb47f948f37d063dabf}{$\sim$\+F\+I\+FO} ()=default
\item 
virtual std\+::size\+\_\+t \hyperlink{class_f_i_f_o_ae80b8555fc249168560c67cd0a13e574}{size} ()=0
\item 
virtual std\+::size\+\_\+t \hyperlink{class_f_i_f_o_ac34aa9afd24e536aad0a9553863b6fe6}{space\+\_\+avail} ()=0
\item 
virtual std\+::size\+\_\+t \hyperlink{class_f_i_f_o_a64565d7156f6796ff14c3033387043b1}{capacity} ()=0
\item 
{\footnotesize template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+nonclass\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\T \& \hyperlink{class_f_i_f_o_a43ad12d67e3611fafae4d6ed862c60b9}{allocate} ()
\item 
{\footnotesize template$<$class T , class ... Args, typename std\+::enable\+\_\+if$<$ inline\+\_\+class\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\T \& \hyperlink{class_f_i_f_o_af3ebfa2420677b5225794a361aa8dccc}{allocate} (Args \&\&... params)
\item 
{\footnotesize template$<$class T , class ... Args, typename std\+::enable\+\_\+if$<$ ext\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\T \& \hyperlink{class_f_i_f_o_af3ebfa2420677b5225794a361aa8dccc}{allocate} (Args \&\&... params)
\item 
virtual void \hyperlink{class_f_i_f_o_af37b9a289093791f4bb9e4ef4e4e271a}{deallocate} ()=0
\item 
{\footnotesize template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+nonclass\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{class_f_i_f_o_a9033768546db45b5f06103d32fec4b65}{allocate\+\_\+s} () -\/$>$ autorelease$<$ T, allocatetype $>$
\item 
{\footnotesize template$<$class T , class ... Args, typename std\+::enable\+\_\+if$<$ inline\+\_\+class\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{class_f_i_f_o_aa5f5334a93f8a014eb19d488898a2e39}{allocate\+\_\+s} (Args \&\&... params) -\/$>$ autorelease$<$ T, allocatetype $>$
\item 
{\footnotesize template$<$class T $>$ }\\auto \hyperlink{class_f_i_f_o_a8b93da58a3fd6ecd844827c4fcbd2473}{allocate\+\_\+range} (const std\+::size\+\_\+t n) -\/$>$ std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ T $>$ $>$
\item 
virtual void \hyperlink{class_f_i_f_o_a0bb564ddace3951ed7754a285b438ba4}{send} (const raft\+::signal=raft\+::none)=0
\item 
virtual void \hyperlink{class_f_i_f_o_ac0be4de6db251e1a2e6dcc97a5d4a584}{send\+\_\+range} (const raft\+::signal=raft\+::none)=0
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{class_f_i_f_o_a381974271d6c818473edd23c355f0d36}{push} (const T \&item, const raft\+::signal signal=raft\+::none)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{class_f_i_f_o_ad1237dfa071d0ca2002bd5aa0ce6d203}{push} (const T \&\&item, const raft\+::signal signal=raft\+::none)
\item 
{\footnotesize template$<$class iterator\+\_\+type $>$ }\\void \hyperlink{class_f_i_f_o_a922b94b854cc9e3ee37fbd447982f663}{insert} (iterator\+\_\+type begin, iterator\+\_\+type end, const raft\+::signal signal=raft\+::none)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{class_f_i_f_o_a0607b6c931ed1fab618e637af617dd15}{pop} (T \&item, raft\+::signal $\ast$signal=nullptr)
\item 
\hypertarget{class_f_i_f_o_ad0ae6389ad4f59a38eb859f1b7d5db1f}{}\label{class_f_i_f_o_ad0ae6389ad4f59a38eb859f1b7d5db1f} 
{\footnotesize template$<$class T $>$ }\\auto {\bfseries pop\+\_\+s} () -\/$>$ autorelease$<$ T, poptype $>$
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{class_f_i_f_o_a23be63e817ff487d32013064e752f02f}{pop\+\_\+range} (pop\+\_\+range\+\_\+t$<$ T $>$ \&items, const std\+::size\+\_\+t n\+\_\+items)
\item 
{\footnotesize template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\T \& \hyperlink{class_f_i_f_o_a8721e94d35fdfb20294ae8478d0baae5}{peek} (raft\+::signal $\ast$signal=nullptr)
\item 
\hypertarget{class_f_i_f_o_a8721e94d35fdfb20294ae8478d0baae5}{}\label{class_f_i_f_o_a8721e94d35fdfb20294ae8478d0baae5} 
{\footnotesize template$<$class T , typename std\+::enable\+\_\+if$<$ ext\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\T \& {\bfseries peek} (raft\+::signal $\ast$signal=nullptr)
\item 
{\footnotesize template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{class_f_i_f_o_ada716e83c59345f73295d3b6f720681f}{peek\+\_\+range} (const std\+::size\+\_\+t n) -\/$>$ autorelease$<$ T, peekrange $>$
\item 
{\footnotesize template$<$class T , typename std\+::enable\+\_\+if$<$ ext\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{class_f_i_f_o_ada716e83c59345f73295d3b6f720681f}{peek\+\_\+range} (const std\+::size\+\_\+t n) -\/$>$ autorelease$<$ T, peekrange $>$
\item 
virtual void \hyperlink{class_f_i_f_o_aa0cbb6c4a5b8783af38c6deb1a6f651e}{unpeek} ()=0
\item 
void \hyperlink{class_f_i_f_o_abac84fe2d1e4b83df8571a97abf9a713}{recycle} (const std\+::size\+\_\+t range=1)
\item 
virtual void \hyperlink{class_f_i_f_o_aa372ba61179c80ce8355aadbdbbad844}{get\+\_\+zero\+\_\+read\+\_\+stats} (\hyperlink{struct_blocked}{Blocked} \&copy)
\item 
virtual void \hyperlink{class_f_i_f_o_a6dd419cc4b99bd13f6b018145844bdd2}{get\+\_\+zero\+\_\+write\+\_\+stats} (\hyperlink{struct_blocked}{Blocked} \&copy)
\item 
virtual void \hyperlink{class_f_i_f_o_a27264d14b86811604a54e0d30aa22c33}{resize} (const std\+::size\+\_\+t n\+\_\+items, const std\+::size\+\_\+t align, volatile bool \&exit\+\_\+alloc)=0
\item 
virtual float \hyperlink{class_f_i_f_o_a4d44784c43a4026508e85982eb3174c7}{get\+\_\+frac\+\_\+write\+\_\+blocked} ()=0
\item 
virtual void \hyperlink{class_f_i_f_o_af65e8231c0d1a7cdf250f2ce57f3723f}{invalidate} ()=0
\item 
virtual bool \hyperlink{class_f_i_f_o_a01bc45169bff5253496dc6bf6f902f89}{is\+\_\+invalid} ()=0
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{class_f_i_f_o_a6d7f0cf28c0eba5eaa12c347734dbdf2}{set\+Ptr\+Map} (ptr\+\_\+map\+\_\+t $\ast$const in)
\item 
virtual void \hyperlink{class_f_i_f_o_a866988c11d53fae77d6ac6f0b56aae56}{set\+Ptr\+Set} (ptr\+\_\+set\+\_\+t $\ast$const out)
\item 
virtual void \hyperlink{class_f_i_f_o_abccc27a45f6590bb8529513c411b0b5a}{set\+In\+Peek\+Set} (ptr\+\_\+set\+\_\+t $\ast$const peekset)
\item 
virtual void \hyperlink{class_f_i_f_o_aaf19d035ab4e130dbcd78c576cdf0dae}{set\+Out\+Peek\+Set} (ptr\+\_\+set\+\_\+t $\ast$const peekset)
\item 
virtual void \hyperlink{class_f_i_f_o_aa9c1f679b4e2585047af2c09a2518209}{set\+\_\+src\+\_\+kernel} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const k)=0
\item 
virtual void \hyperlink{class_f_i_f_o_a11422695c75c05ad2c60e662553f2667}{set\+\_\+dst\+\_\+kernel} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const k)=0
\item 
virtual raft\+::signal \hyperlink{class_f_i_f_o_a36a7519af834c969d49f3d9ae7080af9}{signal\+\_\+peek} ()=0
\item 
virtual void \hyperlink{class_f_i_f_o_ad6b606d47361489007490e0e0b4e2aa1}{signal\+\_\+pop} ()=0
\item 
virtual void \hyperlink{class_f_i_f_o_ae7e91c74078cd52cdfc6f3609b83c8eb}{inline\+\_\+signal\+\_\+send} (const raft\+::signal sig)=0
\item 
virtual void \hyperlink{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{local\+\_\+allocate} (void $\ast$$\ast$ptr)=0
\item 
virtual void \hyperlink{class_f_i_f_o_a4acc34ebbad9df32f54ae8c618ffa0c0}{local\+\_\+allocate\+\_\+n} (void $\ast$ptr, const std\+::size\+\_\+t n)=0
\item 
virtual void \hyperlink{class_f_i_f_o_a4ef48ce2cb02e8bd5d381bb65687e6cb}{local\+\_\+push} (void $\ast$ptr, const raft\+::signal \&signal)=0
\item 
virtual void \hyperlink{class_f_i_f_o_ab3e42eddd74c0c5ce4a640c0cc022245}{local\+\_\+insert} (void $\ast$ptr\+\_\+begin, void $\ast$ptr\+\_\+end, const raft\+::signal \&signal, const std\+::size\+\_\+t iterator\+\_\+type)=0
\item 
virtual void \hyperlink{class_f_i_f_o_ad7ca430a795bbf0904c041dcdfd836a4}{local\+\_\+pop} (void $\ast$ptr, raft\+::signal $\ast$signal)=0
\item 
virtual void \hyperlink{class_f_i_f_o_ab57165cd95da922e5432577893ab2e28}{local\+\_\+pop\+\_\+range} (void $\ast$ptr\+\_\+data, const std\+::size\+\_\+t n\+\_\+items)=0
\item 
virtual void \hyperlink{class_f_i_f_o_afc960790e2803da85fa24e64c61c38b5}{local\+\_\+peek} (void $\ast$$\ast$ptr, raft\+::signal $\ast$signal)=0
\item 
virtual void \hyperlink{class_f_i_f_o_a8056adb06fadf2b7aae4d9858795be45}{local\+\_\+peek\+\_\+range} (void $\ast$$\ast$ptr, void $\ast$$\ast$sig, const std\+::size\+\_\+t n\+\_\+items, std\+::size\+\_\+t \&curr\+\_\+pointer\+\_\+loc)=0
\item 
virtual void \hyperlink{class_f_i_f_o_a72ba5eed0ad96d6f65414f1070a2ac37}{local\+\_\+recycle} (std\+::size\+\_\+t range)=0
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_f_i_f_o_aae5808dc2e987bf17ef42196457a654d}{Schedule}
\item 
\hypertarget{class_f_i_f_o_a64fd97b135f77d4b136e8fff9a1c1ae1}{}\label{class_f_i_f_o_a64fd97b135f77d4b136e8fff9a1c1ae1} 
class {\bfseries Allocate}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 51 of file fifo.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_f_i_f_o_a200f4cf6db6b1994331ee4e0b2a594b1}{}\label{class_f_i_f_o_a200f4cf6db6b1994331ee4e0b2a594b1} 
\index{F\+I\+FO@{F\+I\+FO}!F\+I\+FO@{F\+I\+FO}}
\index{F\+I\+FO@{F\+I\+FO}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{F\+I\+F\+O()}{FIFO()}}
{\footnotesize\ttfamily F\+I\+F\+O\+::\+F\+I\+FO (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

\hyperlink{class_f_i_f_o}{F\+I\+FO} -\/ default constructor for base class for all subsequent ringbuffers. \hypertarget{class_f_i_f_o_a75da1c02fbe46eb47f948f37d063dabf}{}\label{class_f_i_f_o_a75da1c02fbe46eb47f948f37d063dabf} 
\index{F\+I\+FO@{F\+I\+FO}!````~F\+I\+FO@{$\sim$\+F\+I\+FO}}
\index{````~F\+I\+FO@{$\sim$\+F\+I\+FO}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{$\sim$\+F\+I\+F\+O()}{~FIFO()}}
{\footnotesize\ttfamily virtual F\+I\+F\+O\+::$\sim$\+F\+I\+FO (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}

$\sim$\+F\+I\+FO -\/ default destructor 

\subsection{Member Function Documentation}
\hypertarget{class_f_i_f_o_a43ad12d67e3611fafae4d6ed862c60b9}{}\label{class_f_i_f_o_a43ad12d67e3611fafae4d6ed862c60b9} 
\index{F\+I\+FO@{F\+I\+FO}!allocate@{allocate}}
\index{allocate@{allocate}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+nonclass\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
T\& F\+I\+F\+O\+::allocate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

allocate -\/ returns a reference to a writeable member at the tail of the \hyperlink{class_f_i_f_o}{F\+I\+FO}. You must have a subsequent call to send in order to release this object to the \hyperlink{class_f_i_f_o}{F\+I\+FO} once it is written. If the user needs to de-\/allocate the memory without using it, they can call the deallocate function. \begin{DoxyReturn}{Returns}
T\& 
\end{DoxyReturn}
call blocks till an element is available 

Definition at line 101 of file fifo.\+hpp.


\begin{DoxyCode}
102    \{
103       \textcolor{keywordtype}{void} *ptr( \textcolor{keyword}{nullptr} );\textcolor{comment}{}
104 \textcolor{comment}{      /** call blocks till an element is available **/}
105       \hyperlink{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{local\_allocate}( &ptr );
106       \textcolor{keywordflow}{return}( *( reinterpret\_cast< T* >( ptr ) ) );
107    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_af3ebfa2420677b5225794a361aa8dccc}{}\label{class_f_i_f_o_af3ebfa2420677b5225794a361aa8dccc} 
\index{F\+I\+FO@{F\+I\+FO}!allocate@{allocate}}
\index{allocate@{allocate}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$class T , class ... Args, typename std\+::enable\+\_\+if$<$ inline\+\_\+class\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
T\& F\+I\+F\+O\+::allocate (\begin{DoxyParamCaption}\item[{Args \&\&...}]{params }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

call blocks till an element is available 

Definition at line 115 of file fifo.\+hpp.


\begin{DoxyCode}
116    \{
117       \textcolor{keywordtype}{void} *ptr( \textcolor{keyword}{nullptr} );\textcolor{comment}{}
118 \textcolor{comment}{      /** call blocks till an element is available **/}
119       \hyperlink{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{local\_allocate}( &ptr );
120       T * temp( \textcolor{keyword}{new} (ptr) T( std::forward< Args >( params )... ) );
121       UNUSED( temp );
122       \textcolor{keywordflow}{return}( *( reinterpret\_cast< T* >( ptr ) ) );
123    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_af3ebfa2420677b5225794a361aa8dccc}{}\label{class_f_i_f_o_af3ebfa2420677b5225794a361aa8dccc} 
\index{F\+I\+FO@{F\+I\+FO}!allocate@{allocate}}
\index{allocate@{allocate}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$class T , class ... Args, typename std\+::enable\+\_\+if$<$ ext\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
T\& F\+I\+F\+O\+::allocate (\begin{DoxyParamCaption}\item[{Args \&\&...}]{params }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

call blocks till an element is available 

Definition at line 129 of file fifo.\+hpp.


\begin{DoxyCode}
130    \{
131       T **ptr( \textcolor{keyword}{nullptr} );\textcolor{comment}{}
132 \textcolor{comment}{      /** call blocks till an element is available **/}
133       \hyperlink{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{local\_allocate}( (\textcolor{keywordtype}{void}**) &ptr );
134       *ptr = \textcolor{keyword}{new} T( std::forward< Args >( params )... );
135       \textcolor{keywordflow}{return}( **ptr );
136    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a8b93da58a3fd6ecd844827c4fcbd2473}{}\label{class_f_i_f_o_a8b93da58a3fd6ecd844827c4fcbd2473} 
\index{F\+I\+FO@{F\+I\+FO}!allocate\+\_\+range@{allocate\+\_\+range}}
\index{allocate\+\_\+range@{allocate\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{allocate\+\_\+range()}{allocate\_range()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
auto F\+I\+F\+O\+::allocate\+\_\+range (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{n }\end{DoxyParamCaption}) -\/$>$ std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ T $>$ $>$
   \hspace{0.3cm}{\ttfamily [inline]}}

T\+O\+DO, fix allocate\+\_\+range to double buffer properly if not enough mem available allocate\+\_\+range -\/ returns a std\+::vector of references to n items on the queue. If for some reason the capacity of the queue is less than n or some other unspecified error occurs then the number allocated is returned in n\+\_\+ret. To release items to the queue, use push\+\_\+range as opposed to the standard push. 
\begin{DoxyParams}{Parameters}
{\em n} & -\/ const std\+::size\+\_\+t, \# items to allocate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ T $>$ $>$ 
\end{DoxyReturn}
compiler should optimize this copy, if not then it\textquotesingle{}ll be a copy of referneces not full objects 

Definition at line 207 of file fifo.\+hpp.


\begin{DoxyCode}
209    \{
210       std::vector< std::reference\_wrapper< T > > output;
211       \textcolor{keywordtype}{void} *ptr( (\textcolor{keywordtype}{void}*) &output );
212       \hyperlink{class_f_i_f_o_a4acc34ebbad9df32f54ae8c618ffa0c0}{local\_allocate\_n}( ptr, n );\textcolor{comment}{}
213 \textcolor{comment}{      /** compiler should optimize this copy, if not then it'll be a copy of referneces not full objects *
      */}
214       \textcolor{keywordflow}{return}( std::forward<
215          std::vector< 
216             std::reference\_wrapper< T > > >( output ) );
217    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a9033768546db45b5f06103d32fec4b65}{}\label{class_f_i_f_o_a9033768546db45b5f06103d32fec4b65} 
\index{F\+I\+FO@{F\+I\+FO}!allocate\+\_\+s@{allocate\+\_\+s}}
\index{allocate\+\_\+s@{allocate\+\_\+s}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{allocate\+\_\+s()}{allocate\_s()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+nonclass\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
auto F\+I\+F\+O\+::allocate\+\_\+s (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) -\/$>$ autorelease$<$ T, allocatetype $>$
   \hspace{0.3cm}{\ttfamily [inline]}}

allocate\+\_\+s -\/ \char`\"{}auto-\/release\char`\"{} version of allocate, where the action of pushing the memory allocated to the consumer is handled by the returned object exiting the calling stack frame. There are two functions here, one that uses the objec constructor type. This one is for plain old data types. \begin{DoxyReturn}{Returns}
autorelease$<$ T, allocatetype $>$ 
\end{DoxyReturn}


Definition at line 157 of file fifo.\+hpp.


\begin{DoxyCode}
158    \{
159       \textcolor{keywordtype}{void} *ptr( \textcolor{keyword}{nullptr} );
160       \hyperlink{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{local\_allocate}( &ptr );
161       \textcolor{keywordflow}{return}( autorelease< T, allocatetype >( 
162          reinterpret\_cast< T* >( ptr ), (*\textcolor{keyword}{this}) ) );
163    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_aa5f5334a93f8a014eb19d488898a2e39}{}\label{class_f_i_f_o_aa5f5334a93f8a014eb19d488898a2e39} 
\index{F\+I\+FO@{F\+I\+FO}!allocate\+\_\+s@{allocate\+\_\+s}}
\index{allocate\+\_\+s@{allocate\+\_\+s}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{allocate\+\_\+s()}{allocate\_s()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , class ... Args, typename std\+::enable\+\_\+if$<$ inline\+\_\+class\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
auto F\+I\+F\+O\+::allocate\+\_\+s (\begin{DoxyParamCaption}\item[{Args \&\&...}]{params }\end{DoxyParamCaption}) -\/$>$ autorelease$<$ T, allocatetype $>$
   \hspace{0.3cm}{\ttfamily [inline]}}

allocate\+\_\+s -\/ \char`\"{}auto-\/release\char`\"{} version of allocate, where the action of pushing the memory allocated to the consumer is handled by the returned object exiting the calling stack frame. There are two functions here, one that uses the objec constructor type. This one is for object types. \begin{DoxyReturn}{Returns}
autorelease$<$ T, allocatetype $>$ 
\end{DoxyReturn}
call blocks till an element is available 

Definition at line 178 of file fifo.\+hpp.


\begin{DoxyCode}
179    \{
180       \textcolor{keywordtype}{void} *ptr( \textcolor{keyword}{nullptr} );\textcolor{comment}{}
181 \textcolor{comment}{      /** call blocks till an element is available **/}
182       \hyperlink{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{local\_allocate}( &ptr );
183       T * \_\_attribute\_\_((\_\_unused\_\_)) temp( 
184          new (ptr) T( std::forward< Args >( params )... ) );
185       return( autorelease< T, allocatetype >( 
186          reinterpret\_cast< T* >( ptr ), (*this) ) );
187    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a64565d7156f6796ff14c3033387043b1}{}\label{class_f_i_f_o_a64565d7156f6796ff14c3033387043b1} 
\index{F\+I\+FO@{F\+I\+FO}!capacity@{capacity}}
\index{capacity@{capacity}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily virtual std\+::size\+\_\+t F\+I\+F\+O\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

capacity -\/ returns the set maximum capacity of the \hyperlink{class_f_i_f_o}{F\+I\+FO}. \begin{DoxyReturn}{Returns}
std\+::size\+\_\+t 
\end{DoxyReturn}
\hypertarget{class_f_i_f_o_af37b9a289093791f4bb9e4ef4e4e271a}{}\label{class_f_i_f_o_af37b9a289093791f4bb9e4ef4e4e271a} 
\index{F\+I\+FO@{F\+I\+FO}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::deallocate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

deallocate -\/ call after allocate if memory allocated is not needed. Will deallocate all memory allocated by a previous allocate call. \hypertarget{class_f_i_f_o_a4d44784c43a4026508e85982eb3174c7}{}\label{class_f_i_f_o_a4d44784c43a4026508e85982eb3174c7} 
\index{F\+I\+FO@{F\+I\+FO}!get\+\_\+frac\+\_\+write\+\_\+blocked@{get\+\_\+frac\+\_\+write\+\_\+blocked}}
\index{get\+\_\+frac\+\_\+write\+\_\+blocked@{get\+\_\+frac\+\_\+write\+\_\+blocked}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{get\+\_\+frac\+\_\+write\+\_\+blocked()}{get\_frac\_write\_blocked()}}
{\footnotesize\ttfamily virtual float F\+I\+F\+O\+::get\+\_\+frac\+\_\+write\+\_\+blocked (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

get\+\_\+frac\+\_\+write\+\_\+blocked -\/ returns the fraction of time that this queue was blocked. This might become a private function accessible only to the dynamic allocator mechanism, but for now its a public function. \begin{DoxyReturn}{Returns}
float 
\end{DoxyReturn}


Referenced by dynalloc\+::run().

\hypertarget{class_f_i_f_o_aa372ba61179c80ce8355aadbdbbad844}{}\label{class_f_i_f_o_aa372ba61179c80ce8355aadbdbbad844} 
\index{F\+I\+FO@{F\+I\+FO}!get\+\_\+zero\+\_\+read\+\_\+stats@{get\+\_\+zero\+\_\+read\+\_\+stats}}
\index{get\+\_\+zero\+\_\+read\+\_\+stats@{get\+\_\+zero\+\_\+read\+\_\+stats}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{get\+\_\+zero\+\_\+read\+\_\+stats()}{get\_zero\_read\_stats()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::get\+\_\+zero\+\_\+read\+\_\+stats (\begin{DoxyParamCaption}\item[{\hyperlink{struct_blocked}{Blocked} \&}]{copy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

get\+\_\+zero\+\_\+read\+\_\+stats -\/ sets the param variable to the current blocked stats and then sets the current vars to zero. Default version here does nothing, when instrumentation is enabled then the function called actually does something. 
\begin{DoxyParams}{Parameters}
{\em copy} & -\/ \hyperlink{struct_blocked}{Blocked}\&\\
\hline
\end{DoxyParams}
\hyperlink{fifo_8cpp_source}{F\+I\+F\+O.\+cpp} -\/ \begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Thu Sep 4 12\+:59\+:45 2014
\end{DoxyVersion}
Copyright 2014 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. default version does nothing at all 

Definition at line 24 of file fifo.\+cpp.


\begin{DoxyCode}
25 \{\textcolor{comment}{}
26 \textcolor{comment}{   /** default version does nothing at all **/}
27    UNUSED( copy ); 
28    \textcolor{keywordflow}{return};
29 \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a6dd419cc4b99bd13f6b018145844bdd2}{}\label{class_f_i_f_o_a6dd419cc4b99bd13f6b018145844bdd2} 
\index{F\+I\+FO@{F\+I\+FO}!get\+\_\+zero\+\_\+write\+\_\+stats@{get\+\_\+zero\+\_\+write\+\_\+stats}}
\index{get\+\_\+zero\+\_\+write\+\_\+stats@{get\+\_\+zero\+\_\+write\+\_\+stats}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{get\+\_\+zero\+\_\+write\+\_\+stats()}{get\_zero\_write\_stats()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::get\+\_\+zero\+\_\+write\+\_\+stats (\begin{DoxyParamCaption}\item[{\hyperlink{struct_blocked}{Blocked} \&}]{copy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

get\+\_\+zero\+\_\+write\+\_\+stats -\/ sets the param variable to the current blocked stats and then sets the current vars to zero. Default version here does nothing, when instrumentation is enabled then the function, called actually does something. 
\begin{DoxyParams}{Parameters}
{\em copy} & -\/ \hyperlink{struct_blocked}{Blocked}\& \\
\hline
\end{DoxyParams}
default version does nothing at all 

Definition at line 32 of file fifo.\+cpp.


\begin{DoxyCode}
33 \{\textcolor{comment}{}
34 \textcolor{comment}{   /** default version does nothing at all **/}
35    UNUSED( copy );
36    \textcolor{keywordflow}{return};
37 \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_ae7e91c74078cd52cdfc6f3609b83c8eb}{}\label{class_f_i_f_o_ae7e91c74078cd52cdfc6f3609b83c8eb} 
\index{F\+I\+FO@{F\+I\+FO}!inline\+\_\+signal\+\_\+send@{inline\+\_\+signal\+\_\+send}}
\index{inline\+\_\+signal\+\_\+send@{inline\+\_\+signal\+\_\+send}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{inline\+\_\+signal\+\_\+send()}{inline\_signal\_send()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::inline\+\_\+signal\+\_\+send (\begin{DoxyParamCaption}\item[{const raft\+::signal}]{sig }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

inline\+\_\+signal\+\_\+send -\/ pretty much exactly like it sounds, the implementations of this function must pass a signal inline with the data stream so that this signal is received immediately after the data element sent before it. 
\begin{DoxyParams}{Parameters}
{\em sig} & -\/ raft\+::signal, signal to be sent \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a922b94b854cc9e3ee37fbd447982f663}{}\label{class_f_i_f_o_a922b94b854cc9e3ee37fbd447982f663} 
\index{F\+I\+FO@{F\+I\+FO}!insert@{insert}}
\index{insert@{insert}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily template$<$class iterator\+\_\+type $>$ \\
void F\+I\+F\+O\+::insert (\begin{DoxyParamCaption}\item[{iterator\+\_\+type}]{begin,  }\item[{iterator\+\_\+type}]{end,  }\item[{const raft\+::signal}]{signal = {\ttfamily raft\+:\+:none} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

insert -\/ inserts the range from begin to end in the \hyperlink{class_f_i_f_o}{F\+I\+FO}, blocks until space is available. If the range is greater than the space available it\textquotesingle{}ll simply block and add items as space becomes available. There is the implicit assumption that another thread is consuming the data, so eventually there will be room. 
\begin{DoxyParams}{Parameters}
{\em begin} & -\/ iterator\+\_\+type, iterator to begin of range \\
\hline
{\em end} & -\/ iterator\+\_\+type, iterator to end of range \\
\hline
{\em signal} & -\/ raft\+::signal, default raft\+::none \\
\hline
\end{DoxyParams}


Definition at line 287 of file fifo.\+hpp.


\begin{DoxyCode}
290    \{
291       \textcolor{keywordtype}{void} *begin\_ptr( reinterpret\_cast< void* >( &begin ) );
292       \textcolor{keywordtype}{void} *end\_ptr  ( reinterpret\_cast< void* >( &end   ) );
293       \hyperlink{class_f_i_f_o_ab3e42eddd74c0c5ce4a640c0cc022245}{local\_insert}( begin\_ptr, 
294                     end\_ptr, 
295                     signal, 
296                     \textcolor{keyword}{typeid}( iterator\_type ).hash\_code() );
297       \textcolor{keywordflow}{return};
298    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_af65e8231c0d1a7cdf250f2ce57f3723f}{}\label{class_f_i_f_o_af65e8231c0d1a7cdf250f2ce57f3723f} 
\index{F\+I\+FO@{F\+I\+FO}!invalidate@{invalidate}}
\index{invalidate@{invalidate}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{invalidate()}{invalidate()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::invalidate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

invalidate -\/ used by producer thread to label this queue as invalid. Could be for many differing reasons, however the bottom line is that once empty, this queue will receive no extra data and the receiver must do something to deal with this type of behavior if more data is requested. 

Referenced by Schedule\+::quit\+Handler().

\hypertarget{class_f_i_f_o_a01bc45169bff5253496dc6bf6f902f89}{}\label{class_f_i_f_o_a01bc45169bff5253496dc6bf6f902f89} 
\index{F\+I\+FO@{F\+I\+FO}!is\+\_\+invalid@{is\+\_\+invalid}}
\index{is\+\_\+invalid@{is\+\_\+invalid}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{is\+\_\+invalid()}{is\_invalid()}}
{\footnotesize\ttfamily virtual bool F\+I\+F\+O\+::is\+\_\+invalid (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

is\+\_\+invalid -\/ called by the consumer thread to check if this queue is in fact valid. This is typically only called if the queue is empty or if the consumer is asking for more data than is currently available. \begin{DoxyReturn}{Returns}
bool -\/ true if invalid 
\end{DoxyReturn}
\hypertarget{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3}{}\label{class_f_i_f_o_a60068cb00b13626e41d4b11099354ae3} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+allocate@{local\+\_\+allocate}}
\index{local\+\_\+allocate@{local\+\_\+allocate}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+allocate()}{local\_allocate()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+allocate (\begin{DoxyParamCaption}\item[{void $\ast$$\ast$}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+allocate -\/ in order to get this whole thing to work with multiple \char`\"{}ports\char`\"{} contained within the same container we have to erase the type and then put it back. To do this the template function gives a void ptr mem address which is given the location to the head of the queue. Once returned the main allocate function reinterprets this as the proper object type 
\begin{DoxyParams}{Parameters}
{\em ptr} & -\/ void $\ast$$\ast$ \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a4acc34ebbad9df32f54ae8c618ffa0c0}{}\label{class_f_i_f_o_a4acc34ebbad9df32f54ae8c618ffa0c0} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+allocate\+\_\+n@{local\+\_\+allocate\+\_\+n}}
\index{local\+\_\+allocate\+\_\+n@{local\+\_\+allocate\+\_\+n}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+allocate\+\_\+n()}{local\_allocate\_n()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+allocate\+\_\+n (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{const std\+::size\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+allocate\+\_\+n -\/ copies std\+::ref\textquotesingle{}s to the data structure passed in by ptr. 
\begin{DoxyParams}{Parameters}
{\em -\/} & ptr, void$\ast$ dereferenced std\+::vector \\
\hline
{\em -\/} & n, const std\+::size\+\_\+t \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_ab3e42eddd74c0c5ce4a640c0cc022245}{}\label{class_f_i_f_o_ab3e42eddd74c0c5ce4a640c0cc022245} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+insert@{local\+\_\+insert}}
\index{local\+\_\+insert@{local\+\_\+insert}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+insert()}{local\_insert()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+insert (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr\+\_\+begin,  }\item[{void $\ast$}]{ptr\+\_\+end,  }\item[{const raft\+::signal \&}]{signal,  }\item[{const std\+::size\+\_\+t}]{iterator\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+insert -\/ inserts a range from ptr\+\_\+begin to ptr\+\_\+end and inserts the signal at the last element inserted, the rest of the signals are set to raft\+::none. 
\begin{DoxyParams}{Parameters}
{\em ptr\+\_\+begin} & -\/ void$\ast$ \\
\hline
{\em ptr\+\_\+end} & -\/ void$\ast$ \\
\hline
{\em signal} & -\/ const raft\+::signal\& \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_afc960790e2803da85fa24e64c61c38b5}{}\label{class_f_i_f_o_afc960790e2803da85fa24e64c61c38b5} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+peek@{local\+\_\+peek}}
\index{local\+\_\+peek@{local\+\_\+peek}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+peek()}{local\_peek()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+peek (\begin{DoxyParamCaption}\item[{void $\ast$$\ast$}]{ptr,  }\item[{raft\+::signal $\ast$}]{signal }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+peek -\/ peeks at the head of the queue, the element may be modified but not erased. 
\begin{DoxyParams}{Parameters}
{\em ptr} & -\/ void$\ast$$\ast$ \\
\hline
{\em signal} & -\/ raft\+::signal$\ast$ \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a8056adb06fadf2b7aae4d9858795be45}{}\label{class_f_i_f_o_a8056adb06fadf2b7aae4d9858795be45} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+peek\+\_\+range@{local\+\_\+peek\+\_\+range}}
\index{local\+\_\+peek\+\_\+range@{local\+\_\+peek\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+peek\+\_\+range()}{local\_peek\_range()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+peek\+\_\+range (\begin{DoxyParamCaption}\item[{void $\ast$$\ast$}]{ptr,  }\item[{void $\ast$$\ast$}]{sig,  }\item[{const std\+::size\+\_\+t}]{n\+\_\+items,  }\item[{std\+::size\+\_\+t \&}]{curr\+\_\+pointer\+\_\+loc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+peek\+\_\+range -\/ peeks at head of queue with the specified range, data may be modified but not erased. Since the queue might be non-\/contiguous then we must return the memory location of each element. 
\begin{DoxyParams}{Parameters}
{\em ptr} & -\/ void$\ast$$\ast$, pointer to pointers at which to store the pointers to items on the queue \\
\hline
{\em sig} & -\/ void$\ast$$\ast$, same as above but for signal queue \\
\hline
{\em n\+\_\+items} & -\/ const std\+::size\+\_\+t, number of items requested \\
\hline
{\em curr\+\_\+pointer\+\_\+loc} & -\/ number of items able to be returned \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_ad7ca430a795bbf0904c041dcdfd836a4}{}\label{class_f_i_f_o_ad7ca430a795bbf0904c041dcdfd836a4} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+pop@{local\+\_\+pop}}
\index{local\+\_\+pop@{local\+\_\+pop}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+pop()}{local\_pop()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+pop (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{raft\+::signal $\ast$}]{signal }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+pop -\/ makes a copy, pops an item from the queue and stores the copy at memory located at $\ast$ptr. 
\begin{DoxyParams}{Parameters}
{\em ptr} & -\/ void$\ast$ \\
\hline
{\em signal} & -\/ raft\+::signal$\ast$ \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_ab57165cd95da922e5432577893ab2e28}{}\label{class_f_i_f_o_ab57165cd95da922e5432577893ab2e28} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+pop\+\_\+range@{local\+\_\+pop\+\_\+range}}
\index{local\+\_\+pop\+\_\+range@{local\+\_\+pop\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+pop\+\_\+range()}{local\_pop\_range()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+pop\+\_\+range (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr\+\_\+data,  }\item[{const std\+::size\+\_\+t}]{n\+\_\+items }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+pop\+\_\+range -\/ pops a range, of n\+\_\+items and stores them to the array of T$\ast$ items pointed to by ptr\+\_\+data. 
\begin{DoxyParams}{Parameters}
{\em ptr\+\_\+data} & -\/ void$\ast$ \\
\hline
{\em n\+\_\+items} & -\/ std\+::size\+\_\+t \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a4ef48ce2cb02e8bd5d381bb65687e6cb}{}\label{class_f_i_f_o_a4ef48ce2cb02e8bd5d381bb65687e6cb} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+push@{local\+\_\+push}}
\index{local\+\_\+push@{local\+\_\+push}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+push()}{local\_push()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+push (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr,  }\item[{const raft\+::signal \&}]{signal }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+push -\/ pushes the object reference by the void ptr and pushes it to the \hyperlink{class_f_i_f_o}{F\+I\+FO} with the associated signal. Once this function returns, the value is copied according to the objects copy constructor, which should be set up to \char`\"{}deep\char`\"{} copy the object 
\begin{DoxyParams}{Parameters}
{\em ptr} & -\/ void$\ast$ \\
\hline
{\em signal} & -\/ raft\+::signal reference \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a72ba5eed0ad96d6f65414f1070a2ac37}{}\label{class_f_i_f_o_a72ba5eed0ad96d6f65414f1070a2ac37} 
\index{F\+I\+FO@{F\+I\+FO}!local\+\_\+recycle@{local\+\_\+recycle}}
\index{local\+\_\+recycle@{local\+\_\+recycle}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{local\+\_\+recycle()}{local\_recycle()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::local\+\_\+recycle (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{range }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

local\+\_\+recycle -\/ called by template recycle function after calling destructor (for non-\/\+P\+OD types). 
\begin{DoxyParams}{Parameters}
{\em range} & -\/ std\+::size\+\_\+t \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a8721e94d35fdfb20294ae8478d0baae5}{}\label{class_f_i_f_o_a8721e94d35fdfb20294ae8478d0baae5} 
\index{F\+I\+FO@{F\+I\+FO}!peek@{peek}}
\index{peek@{peek}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{peek()}{peek()}}
{\footnotesize\ttfamily template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
T\& F\+I\+F\+O\+::peek (\begin{DoxyParamCaption}\item[{raft\+::signal $\ast$}]{signal = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

peek -\/ returns a reference to the head of the queue. \hyperlink{class_f_i_f_o_aa0cbb6c4a5b8783af38c6deb1a6f651e}{unpeek()} must be called after this to tell the runtime that the reference is no longer being used. 
\begin{DoxyParams}{Parameters}
{\em signal} & -\/ raft\+::signal, default\+: nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
T\& 
\end{DoxyReturn}


Definition at line 351 of file fifo.\+hpp.


\begin{DoxyCode}
352    \{
353       \textcolor{keywordtype}{void} *ptr( \textcolor{keyword}{nullptr} );
354       \hyperlink{class_f_i_f_o_afc960790e2803da85fa24e64c61c38b5}{local\_peek}( &ptr, signal );
355       \textcolor{keywordflow}{return}( *( reinterpret\_cast< T* >( ptr ) ) );
356    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_ada716e83c59345f73295d3b6f720681f}{}\label{class_f_i_f_o_ada716e83c59345f73295d3b6f720681f} 
\index{F\+I\+FO@{F\+I\+FO}!peek\+\_\+range@{peek\+\_\+range}}
\index{peek\+\_\+range@{peek\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{peek\+\_\+range()}{peek\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T , typename std\+::enable\+\_\+if$<$ inline\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
auto F\+I\+F\+O\+::peek\+\_\+range (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{n }\end{DoxyParamCaption}) -\/$>$ autorelease$<$ T, peekrange $>$
   \hspace{0.3cm}{\ttfamily [inline]}}

peek\+\_\+range -\/ analogous to peek, only the user gets a list of items. \hyperlink{class_f_i_f_o_aa0cbb6c4a5b8783af38c6deb1a6f651e}{unpeek()} must be called after using this function to let the runtime know that the user is done with the references. @ n -\/ const std\+::size\+\_\+t, number of items to peek \begin{DoxyReturn}{Returns}
-\/ std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ T $>$ $>$ 
\end{DoxyReturn}


Definition at line 377 of file fifo.\+hpp.


\begin{DoxyCode}
379    \{
380       \textcolor{keywordtype}{void} *ptr = \textcolor{keyword}{nullptr};
381       \textcolor{keywordtype}{void} *sig = \textcolor{keyword}{nullptr};
382       std::size\_t curr\_pointer\_loc( 0 );
383       \hyperlink{class_f_i_f_o_a8056adb06fadf2b7aae4d9858795be45}{local\_peek\_range}( &ptr, &sig, n, curr\_pointer\_loc );
384       \textcolor{keywordflow}{return}( autorelease< T, peekrange >( 
385          (*\textcolor{keyword}{this}),
386          reinterpret\_cast< T * const >( ptr ),
387          reinterpret\_cast< Buffer::Signal* >( sig ),
388          curr\_pointer\_loc,
389          n ) );
390    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_ada716e83c59345f73295d3b6f720681f}{}\label{class_f_i_f_o_ada716e83c59345f73295d3b6f720681f} 
\index{F\+I\+FO@{F\+I\+FO}!peek\+\_\+range@{peek\+\_\+range}}
\index{peek\+\_\+range@{peek\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{peek\+\_\+range()}{peek\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T , typename std\+::enable\+\_\+if$<$ ext\+\_\+alloc$<$ T $>$\+::value $>$\+::type $\ast$  = nullptr$>$ \\
auto F\+I\+F\+O\+::peek\+\_\+range (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{n }\end{DoxyParamCaption}) -\/$>$ autorelease$<$ T, peekrange $>$
   \hspace{0.3cm}{\ttfamily [inline]}}

F\+I\+X\+ME\+: still not implemented yet for externally allocated objects 

Definition at line 394 of file fifo.\+hpp.


\begin{DoxyCode}
396    \{\textcolor{comment}{}
397 \textcolor{comment}{      /** FIXME: still not implemented yet for externally allocated objects **/}
398       assert( \textcolor{keyword}{false} );
399       \textcolor{keywordtype}{void} *ptr = \textcolor{keyword}{nullptr};
400       \textcolor{keywordtype}{void} *sig = \textcolor{keyword}{nullptr};
401       std::size\_t curr\_pointer\_loc( 0 );
402       \hyperlink{class_f_i_f_o_a8056adb06fadf2b7aae4d9858795be45}{local\_peek\_range}( &ptr, &sig, n, curr\_pointer\_loc );
403       \textcolor{keywordflow}{return}( autorelease< T, peekrange >( 
404          (*\textcolor{keyword}{this}),
405          reinterpret\_cast< T * const >( ptr ),
406          reinterpret\_cast< Buffer::Signal* >( sig ),
407          curr\_pointer\_loc,
408          n ) );
409    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a0607b6c931ed1fab618e637af617dd15}{}\label{class_f_i_f_o_a0607b6c931ed1fab618e637af617dd15} 
\index{F\+I\+FO@{F\+I\+FO}!pop@{pop}}
\index{pop@{pop}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{pop()}{pop()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void F\+I\+F\+O\+::pop (\begin{DoxyParamCaption}\item[{T \&}]{item,  }\item[{raft\+::signal $\ast$}]{signal = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

pop -\/ pops the head of the queue. If the receiving object wants to watch use the signal, then the signal parameter should not be null. 
\begin{DoxyParams}{Parameters}
{\em item} & -\/ T\& \\
\hline
{\em signal} & -\/ raft\+::signal \\
\hline
\end{DoxyParams}


Definition at line 308 of file fifo.\+hpp.


\begin{DoxyCode}
309    \{
310       \textcolor{keywordtype}{void} *ptr( reinterpret\_cast< void* >( &item ) );
311       \hyperlink{class_f_i_f_o_ad7ca430a795bbf0904c041dcdfd836a4}{local\_pop}( ptr, signal );
312       \textcolor{keywordflow}{return};
313    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a23be63e817ff487d32013064e752f02f}{}\label{class_f_i_f_o_a23be63e817ff487d32013064e752f02f} 
\index{F\+I\+FO@{F\+I\+FO}!pop\+\_\+range@{pop\+\_\+range}}
\index{pop\+\_\+range@{pop\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{pop\+\_\+range()}{pop\_range()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void F\+I\+F\+O\+::pop\+\_\+range (\begin{DoxyParamCaption}\item[{pop\+\_\+range\+\_\+t$<$ T $>$ \&}]{items,  }\item[{const std\+::size\+\_\+t}]{n\+\_\+items }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

pop\+\_\+range -\/ pops n\+\_\+items from the buffer into the std\+::vector pointed to by pop\+\_\+range. There are two different ways this function could operate, either with a push\+\_\+back type symantic which would mean three copies or dealing with a pre-\/allocated vector. This function assumes that the user has allocated a vector withthe correct size (= n\+\_\+items). 
\begin{DoxyParams}{Parameters}
{\em items} & -\/ std\+::vector$<$ std\+::pair$<$ T, raft\+::signal $>$ $>$\& \\
\hline
{\em n\+\_\+items} & -\/ std\+::size\+\_\+t \\
\hline
\end{DoxyParams}


Definition at line 333 of file fifo.\+hpp.


\begin{DoxyCode}
335    \{
336       \textcolor{keywordtype}{void} *ptr\_items( (\textcolor{keywordtype}{void}*)&items );
337       \hyperlink{class_f_i_f_o_ab57165cd95da922e5432577893ab2e28}{local\_pop\_range}( ptr\_items, n\_items );
338       \textcolor{keywordflow}{return};
339    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a381974271d6c818473edd23c355f0d36}{}\label{class_f_i_f_o_a381974271d6c818473edd23c355f0d36} 
\index{F\+I\+FO@{F\+I\+FO}!push@{push}}
\index{push@{push}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{push()}{push()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void F\+I\+F\+O\+::push (\begin{DoxyParamCaption}\item[{const T \&}]{item,  }\item[{const raft\+::signal}]{signal = {\ttfamily raft\+:\+:none} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

push -\/ function which takes an object of type T and a signal, makes a copy of the object using the copy constructor and passes it to the \hyperlink{class_f_i_f_o}{F\+I\+FO} along with the signal which is guaranteed to be delivered at the same time as the object (if of course the receiving object is responding to signals). 
\begin{DoxyParams}{Parameters}
{\em item} & -\/ T\& \\
\hline
{\em signal} & -\/ raft\+::signal, default raft\+::none \\
\hline
\end{DoxyParams}
call blocks till element is written and released to queue 

Definition at line 247 of file fifo.\+hpp.


\begin{DoxyCode}
248    \{
249       \textcolor{keywordtype}{void} * \textcolor{keyword}{const} ptr( (\textcolor{keywordtype}{void}*) &item );\textcolor{comment}{}
250 \textcolor{comment}{      /** call blocks till element is written and released to queue **/}
251       \hyperlink{class_f_i_f_o_a4ef48ce2cb02e8bd5d381bb65687e6cb}{local\_push}( ptr, signal );
252       \textcolor{keywordflow}{return};
253    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_ad1237dfa071d0ca2002bd5aa0ce6d203}{}\label{class_f_i_f_o_ad1237dfa071d0ca2002bd5aa0ce6d203} 
\index{F\+I\+FO@{F\+I\+FO}!push@{push}}
\index{push@{push}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{push()}{push()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void F\+I\+F\+O\+::push (\begin{DoxyParamCaption}\item[{const T \&\&}]{item,  }\item[{const raft\+::signal}]{signal = {\ttfamily raft\+:\+:none} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

push -\/ function which takes an object of type T and a signal, makes a copy of the object using the copy constructor and passes it to the \hyperlink{class_f_i_f_o}{F\+I\+FO} along with the signal which is guaranteed to be delivered at the same time as the object (if of course the receiving object is responding to signals). 
\begin{DoxyParams}{Parameters}
{\em item} & -\/ T\&\& \\
\hline
{\em signal} & -\/ raft\+::signal, default raft\+::none \\
\hline
\end{DoxyParams}
call blocks till element is written and released to queue 

Definition at line 266 of file fifo.\+hpp.


\begin{DoxyCode}
267    \{
268       \textcolor{keywordtype}{void} * \textcolor{keyword}{const} ptr( (\textcolor{keywordtype}{void}*) &item );\textcolor{comment}{}
269 \textcolor{comment}{      /** call blocks till element is written and released to queue **/}
270       \hyperlink{class_f_i_f_o_a4ef48ce2cb02e8bd5d381bb65687e6cb}{local\_push}( ptr, signal );
271       \textcolor{keywordflow}{return};
272    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_abac84fe2d1e4b83df8571a97abf9a713}{}\label{class_f_i_f_o_abac84fe2d1e4b83df8571a97abf9a713} 
\index{F\+I\+FO@{F\+I\+FO}!recycle@{recycle}}
\index{recycle@{recycle}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{recycle()}{recycle()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::recycle (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{range = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

recycle -\/ so you want to ignore some items from the input stream without ever even looking at them, then this is the function for you. It is also used with the peek call in order to invalidate or free memory to the queue so that the next peek or pop operation will see a a different location. 
\begin{DoxyParams}{Parameters}
{\em t} & -\/ refernce to object or type of object to be recycled, can be null or invalid since this function will never access it. \\
\hline
{\em range} & -\/ const std\+::size\+\_\+t \\
\hline
\end{DoxyParams}


Definition at line 435 of file fifo.\+hpp.


\begin{DoxyCode}
436    \{
437       \hyperlink{class_f_i_f_o_a72ba5eed0ad96d6f65414f1070a2ac37}{local\_recycle}( range ); 
438    \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a27264d14b86811604a54e0d30aa22c33}{}\label{class_f_i_f_o_a27264d14b86811604a54e0d30aa22c33} 
\index{F\+I\+FO@{F\+I\+FO}!resize@{resize}}
\index{resize@{resize}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{resize()}{resize()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::resize (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{n\+\_\+items,  }\item[{const std\+::size\+\_\+t}]{align,  }\item[{volatile bool \&}]{exit\+\_\+alloc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

resize -\/ called from the dynamic allocator to resize the queue. The function itself is implemented in the various template specializations found in ringuffer.\+tcc. A new queue is allocated with the size specified and alignment and the old queue is copied over. The third parameter, exit\+\_\+alloc must be passed from the dynamic allocator to signal with the application is finished so that the resize function doesn\textquotesingle{}t wait indefinitely for queue conditions that will never arise (for exact conditions, see datamanager.\+tcc. 
\begin{DoxyParams}{Parameters}
{\em n\+\_\+items} & -\/ number of items to resize q to \\
\hline
{\em align} & -\/ alignment of queue to allocate \\
\hline
{\em exit\+\_\+alloc} & -\/ bool to signal when app is finished \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a0bb564ddace3951ed7754a285b438ba4}{}\label{class_f_i_f_o_a0bb564ddace3951ed7754a285b438ba4} 
\index{F\+I\+FO@{F\+I\+FO}!send@{send}}
\index{send@{send}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{send()}{send()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::send (\begin{DoxyParamCaption}\item[{const raft\+::signal}]{ = {\ttfamily raft\+:\+:none} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

send -\/ releases the last item allocated by \hyperlink{class_f_i_f_o_a43ad12d67e3611fafae4d6ed862c60b9}{allocate()} to the queue. Function will simply return if allocate wasn\textquotesingle{}t called prior to calling this function. 
\begin{DoxyParams}{Parameters}
{\em signal} & -\/ const raft\+::signal, default\+: N\+O\+NE \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_ac0be4de6db251e1a2e6dcc97a5d4a584}{}\label{class_f_i_f_o_ac0be4de6db251e1a2e6dcc97a5d4a584} 
\index{F\+I\+FO@{F\+I\+FO}!send\+\_\+range@{send\+\_\+range}}
\index{send\+\_\+range@{send\+\_\+range}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{send\+\_\+range()}{send\_range()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::send\+\_\+range (\begin{DoxyParamCaption}\item[{const raft\+::signal}]{ = {\ttfamily raft\+:\+:none} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

send\+\_\+range -\/ releases the items allocated by allocate\+\_\+range to the queue. Function will simply return if allocate wasn\textquotesingle{}t called prior to calling this function. 
\begin{DoxyParams}{Parameters}
{\em signal} & -\/ const raft\+::signal, default\+: N\+O\+NE \\
\hline
\end{DoxyParams}
\hypertarget{class_f_i_f_o_a11422695c75c05ad2c60e662553f2667}{}\label{class_f_i_f_o_a11422695c75c05ad2c60e662553f2667} 
\index{F\+I\+FO@{F\+I\+FO}!set\+\_\+dst\+\_\+kernel@{set\+\_\+dst\+\_\+kernel}}
\index{set\+\_\+dst\+\_\+kernel@{set\+\_\+dst\+\_\+kernel}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{set\+\_\+dst\+\_\+kernel()}{set\_dst\_kernel()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::set\+\_\+dst\+\_\+kernel (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

set\+\_\+dst\+\_\+kernel -\/ sets the protected destination kernel for this fifo, necessary for preemption, see comments on variables below. 
\begin{DoxyParams}{Parameters}
{\em k} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \\
\hline
\end{DoxyParams}


Referenced by Allocate\+::initialize().

\hypertarget{class_f_i_f_o_aa9c1f679b4e2585047af2c09a2518209}{}\label{class_f_i_f_o_aa9c1f679b4e2585047af2c09a2518209} 
\index{F\+I\+FO@{F\+I\+FO}!set\+\_\+src\+\_\+kernel@{set\+\_\+src\+\_\+kernel}}
\index{set\+\_\+src\+\_\+kernel@{set\+\_\+src\+\_\+kernel}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{set\+\_\+src\+\_\+kernel()}{set\_src\_kernel()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::set\+\_\+src\+\_\+kernel (\begin{DoxyParamCaption}\item[{\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

set\+\_\+src\+\_\+kernel -\/ sets teh protected source kernel for this fifo, necessary for preemption, see comments on variables below. 
\begin{DoxyParams}{Parameters}
{\em k} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \\
\hline
\end{DoxyParams}


Referenced by Allocate\+::initialize().

\hypertarget{class_f_i_f_o_abccc27a45f6590bb8529513c411b0b5a}{}\label{class_f_i_f_o_abccc27a45f6590bb8529513c411b0b5a} 
\index{F\+I\+FO@{F\+I\+FO}!set\+In\+Peek\+Set@{set\+In\+Peek\+Set}}
\index{set\+In\+Peek\+Set@{set\+In\+Peek\+Set}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{set\+In\+Peek\+Set()}{setInPeekSet()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::set\+In\+Peek\+Set (\begin{DoxyParamCaption}\item[{ptr\+\_\+set\+\_\+t $\ast$const}]{peekset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

set\+In\+Peek\+Set -\/ 

Definition at line 54 of file fifo.\+cpp.


\begin{DoxyCode}
55 \{
56     UNUSED( peekset );
57     \textcolor{keywordflow}{return};
58 \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_aaf19d035ab4e130dbcd78c576cdf0dae}{}\label{class_f_i_f_o_aaf19d035ab4e130dbcd78c576cdf0dae} 
\index{F\+I\+FO@{F\+I\+FO}!set\+Out\+Peek\+Set@{set\+Out\+Peek\+Set}}
\index{set\+Out\+Peek\+Set@{set\+Out\+Peek\+Set}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{set\+Out\+Peek\+Set()}{setOutPeekSet()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::set\+Out\+Peek\+Set (\begin{DoxyParamCaption}\item[{ptr\+\_\+set\+\_\+t $\ast$const}]{peekset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

set\+Out\+Peek\+Set -\/ 

Definition at line 61 of file fifo.\+cpp.


\begin{DoxyCode}
62 \{
63     UNUSED( peekset );
64     \textcolor{keywordflow}{return};
65 \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a6d7f0cf28c0eba5eaa12c347734dbdf2}{}\label{class_f_i_f_o_a6d7f0cf28c0eba5eaa12c347734dbdf2} 
\index{F\+I\+FO@{F\+I\+FO}!set\+Ptr\+Map@{set\+Ptr\+Map}}
\index{set\+Ptr\+Map@{set\+Ptr\+Map}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{set\+Ptr\+Map()}{setPtrMap()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::set\+Ptr\+Map (\begin{DoxyParamCaption}\item[{ptr\+\_\+map\+\_\+t $\ast$const}]{in }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

set\+Ptr\+Map -\/ 

Definition at line 40 of file fifo.\+cpp.


\begin{DoxyCode}
41 \{
42     UNUSED( in );
43     \textcolor{keywordflow}{return};
44 \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a866988c11d53fae77d6ac6f0b56aae56}{}\label{class_f_i_f_o_a866988c11d53fae77d6ac6f0b56aae56} 
\index{F\+I\+FO@{F\+I\+FO}!set\+Ptr\+Set@{set\+Ptr\+Set}}
\index{set\+Ptr\+Set@{set\+Ptr\+Set}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{set\+Ptr\+Set()}{setPtrSet()}}
{\footnotesize\ttfamily void F\+I\+F\+O\+::set\+Ptr\+Set (\begin{DoxyParamCaption}\item[{ptr\+\_\+set\+\_\+t $\ast$const}]{out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

set\+Ptr\+Set -\/ 

Definition at line 47 of file fifo.\+cpp.


\begin{DoxyCode}
48 \{
49     UNUSED( out );
50     \textcolor{keywordflow}{return};
51 \}
\end{DoxyCode}
\hypertarget{class_f_i_f_o_a36a7519af834c969d49f3d9ae7080af9}{}\label{class_f_i_f_o_a36a7519af834c969d49f3d9ae7080af9} 
\index{F\+I\+FO@{F\+I\+FO}!signal\+\_\+peek@{signal\+\_\+peek}}
\index{signal\+\_\+peek@{signal\+\_\+peek}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{signal\+\_\+peek()}{signal\_peek()}}
{\footnotesize\ttfamily virtual raft\+::signal F\+I\+F\+O\+::signal\+\_\+peek (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

signal\+\_\+peek -\/ special function for the scheduler to peek at a signal on the head of the queue. \begin{DoxyReturn}{Returns}
raft\+::signal 
\end{DoxyReturn}
\hypertarget{class_f_i_f_o_ad6b606d47361489007490e0e0b4e2aa1}{}\label{class_f_i_f_o_ad6b606d47361489007490e0e0b4e2aa1} 
\index{F\+I\+FO@{F\+I\+FO}!signal\+\_\+pop@{signal\+\_\+pop}}
\index{signal\+\_\+pop@{signal\+\_\+pop}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{signal\+\_\+pop()}{signal\_pop()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::signal\+\_\+pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

signal\+\_\+pop -\/ special function fo rthe scheduler to pop the current signal and associated item. \hypertarget{class_f_i_f_o_ae80b8555fc249168560c67cd0a13e574}{}\label{class_f_i_f_o_ae80b8555fc249168560c67cd0a13e574} 
\index{F\+I\+FO@{F\+I\+FO}!size@{size}}
\index{size@{size}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily virtual std\+::size\+\_\+t F\+I\+F\+O\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

size -\/ returns the current size of this \hyperlink{class_f_i_f_o}{F\+I\+FO} \begin{DoxyReturn}{Returns}
std\+::size\+\_\+t 
\end{DoxyReturn}
\hypertarget{class_f_i_f_o_ac34aa9afd24e536aad0a9553863b6fe6}{}\label{class_f_i_f_o_ac34aa9afd24e536aad0a9553863b6fe6} 
\index{F\+I\+FO@{F\+I\+FO}!space\+\_\+avail@{space\+\_\+avail}}
\index{space\+\_\+avail@{space\+\_\+avail}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{space\+\_\+avail()}{space\_avail()}}
{\footnotesize\ttfamily virtual std\+::size\+\_\+t F\+I\+F\+O\+::space\+\_\+avail (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

space\+\_\+avail -\/ convenience function to get the current space available in the \hyperlink{class_f_i_f_o}{F\+I\+FO}, could otherwise be calculated by taking the \hyperlink{class_f_i_f_o_a64565d7156f6796ff14c3033387043b1}{capacity()} -\/ \hyperlink{class_f_i_f_o_ae80b8555fc249168560c67cd0a13e574}{size()}. \begin{DoxyReturn}{Returns}
std\+::size\+\_\+t 
\end{DoxyReturn}
\hypertarget{class_f_i_f_o_aa0cbb6c4a5b8783af38c6deb1a6f651e}{}\label{class_f_i_f_o_aa0cbb6c4a5b8783af38c6deb1a6f651e} 
\index{F\+I\+FO@{F\+I\+FO}!unpeek@{unpeek}}
\index{unpeek@{unpeek}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{unpeek()}{unpeek()}}
{\footnotesize\ttfamily virtual void F\+I\+F\+O\+::unpeek (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

unpeek -\/ call after peek to let the runtime know that all references to the returned value are no longer in use. Keeps the memory location in a valid state for that input port, i.\+e., it doesn\textquotesingle{}t release the memory location so that the next call to peek will return the same exact location. A call to recycle will release the memory, or invalidate it. 

\subsection{Friends And Related Function Documentation}
\hypertarget{class_f_i_f_o_aae5808dc2e987bf17ef42196457a654d}{}\label{class_f_i_f_o_aae5808dc2e987bf17ef42196457a654d} 
\index{F\+I\+FO@{F\+I\+FO}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!F\+I\+FO@{F\+I\+FO}}
\subsubsection{\texorpdfstring{Schedule}{Schedule}}
{\footnotesize\ttfamily friend class \hyperlink{class_schedule}{Schedule}\hspace{0.3cm}{\ttfamily [friend]}}

needed to keep as a friend for signalling access 

Definition at line 659 of file fifo.\+hpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
fifo.\+hpp\item 
fifo.\+cpp\end{DoxyCompactItemize}
