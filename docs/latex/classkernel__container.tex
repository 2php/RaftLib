\hypertarget{classkernel__container}{}\section{kernel\+\_\+container Class Reference}
\label{classkernel__container}\index{kernel\+\_\+container@{kernel\+\_\+container}}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classkernel__container_aaa8403088c93fca461e37158069d91b5}{}\label{classkernel__container_aaa8403088c93fca461e37158069d91b5} 
using {\bfseries buffer} = Ring\+Buffer$<$ \hyperlink{structsched__cmd__t}{sched\+\_\+cmd\+\_\+t}, Type\+::\+Ring\+Buffer\+Type\+::\+Heap, false $>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classkernel__container_a273d59eff9b9e269f1f9b231abc37b83}{kernel\+\_\+container} ()
\item 
\hyperlink{classkernel__container_a6d97cddd3d2f015166485afad9c71ff5}{kernel\+\_\+container} (const std\+::size\+\_\+t N)
\item 
\hyperlink{classkernel__container_acec164e3f4c6f37f4791c90c24514b34}{$\sim$kernel\+\_\+container} ()
\item 
buffer \& \hyperlink{classkernel__container_abcbec3854917b37bd6421b6b8ed2c2c0}{get\+Input\+Queue} ()
\item 
buffer \& \hyperlink{classkernel__container_a64384e258fee9b664d164eb50baf33df}{get\+Output\+Queue} ()
\item 
std\+::size\+\_\+t \hyperlink{classkernel__container_a358a15b772f1b7dfa57bd733fc78fcaa}{size} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classkernel__container_a89f9b11119d9ab0e8c64215bf50856f0}{container\+\_\+run} (\hyperlink{classkernel__container}{kernel\+\_\+container} \&container)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 36 of file kernelcontainer.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classkernel__container_a273d59eff9b9e269f1f9b231abc37b83}{}\label{classkernel__container_a273d59eff9b9e269f1f9b231abc37b83} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!kernel\+\_\+container@{kernel\+\_\+container}}
\index{kernel\+\_\+container@{kernel\+\_\+container}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{kernel\+\_\+container()}{kernel\_container()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily kernel\+\_\+container\+::kernel\+\_\+container (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\hyperlink{classkernel__container}{kernel\+\_\+container} -\/ default constructor, initializes all above pointers.

\hyperlink{kernelcontainer_8cpp_source}{kernelcontainer.\+cpp} -\/ \begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Sun Mar 22 09\+:13\+:32 2015
\end{DoxyVersion}
Copyright 2015 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 

Definition at line 27 of file kernelcontainer.\+cpp.


\begin{DoxyCode}
28 \{
29    input\_buff  = \textcolor{keyword}{new} buffer( 100 );
30    output\_buff = \textcolor{keyword}{new} buffer( 100 );
31 \}
\end{DoxyCode}
\hypertarget{classkernel__container_a6d97cddd3d2f015166485afad9c71ff5}{}\label{classkernel__container_a6d97cddd3d2f015166485afad9c71ff5} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!kernel\+\_\+container@{kernel\+\_\+container}}
\index{kernel\+\_\+container@{kernel\+\_\+container}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{kernel\+\_\+container()}{kernel\_container()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily kernel\+\_\+container\+::kernel\+\_\+container (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{N }\end{DoxyParamCaption})}

\hyperlink{classkernel__container}{kernel\+\_\+container} -\/ constructor, initializes all above pointers. 
\begin{DoxyParams}{Parameters}
{\em N} & -\/ const std\+::size\+\_\+t, default size of buffer \\
\hline
\end{DoxyParams}


Definition at line 33 of file kernelcontainer.\+cpp.


\begin{DoxyCode}
34 \{
35    input\_buff  = \textcolor{keyword}{new} buffer( N );
36    output\_buff = \textcolor{keyword}{new} buffer( N );
37 \}
\end{DoxyCode}
\hypertarget{classkernel__container_acec164e3f4c6f37f4791c90c24514b34}{}\label{classkernel__container_acec164e3f4c6f37f4791c90c24514b34} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!````~kernel\+\_\+container@{$\sim$kernel\+\_\+container}}
\index{````~kernel\+\_\+container@{$\sim$kernel\+\_\+container}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{$\sim$kernel\+\_\+container()}{~kernel\_container()}}
{\footnotesize\ttfamily kernel\+\_\+container\+::$\sim$kernel\+\_\+container (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

default destructor, cleans up all pointers 

Definition at line 40 of file kernelcontainer.\+cpp.


\begin{DoxyCode}
41 \{
42    \textcolor{keyword}{delete}( input\_buff );
43    \textcolor{keyword}{delete}( output\_buff );
44 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classkernel__container_a89f9b11119d9ab0e8c64215bf50856f0}{}\label{classkernel__container_a89f9b11119d9ab0e8c64215bf50856f0} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!container\+\_\+run@{container\+\_\+run}}
\index{container\+\_\+run@{container\+\_\+run}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{container\+\_\+run()}{container\_run()}}
{\footnotesize\ttfamily void kernel\+\_\+container\+::container\+\_\+run (\begin{DoxyParamCaption}\item[{\hyperlink{classkernel__container}{kernel\+\_\+container} \&}]{container }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

container\+\_\+run -\/ function to be used by a thread which is called until the appropriate signal is sent (defined in \hyperlink{sched__cmd__t_8hpp_source}{sched\+\_\+cmd\+\_\+t.\+hpp}. 
\begin{DoxyParams}{Parameters}
{\em container} & -\/ \hyperlink{classkernel__container}{kernel\+\_\+container}\& \\
\hline
\end{DoxyParams}
clean-\/up buffer and recycle head of \hyperlink{class_f_i_f_o}{F\+I\+FO}

just in case, a sanity check here

try these kernels again

after this it\textquotesingle{}ll longjmp to the running state 

Definition at line 62 of file kernelcontainer.\+cpp.



References sched\+\_\+cmd\+\_\+t\+::cmd, get\+Input\+Queue(), get\+Output\+Queue(), sched\+\_\+cmd\+\_\+t\+::kernel, and Schedule\+::kernel\+Run().


\begin{DoxyCode}
63 \{
64    \textcolor{keywordtype}{bool} shutdown( \textcolor{keyword}{false} );
65    \textcolor{keyword}{auto} &input\_buffer( container.\hyperlink{classkernel__container_abcbec3854917b37bd6421b6b8ed2c2c0}{getInputQueue}() );
66    \textcolor{keyword}{auto} &output\_buffer( container.\hyperlink{classkernel__container_a64384e258fee9b664d164eb50baf33df}{getOutputQueue}() );
67    \textcolor{keywordflow}{while}( ! shutdown || container.preempted\_kernel\_pool.size() > 0 )
68    \{
69       \textcolor{keywordflow}{if}( container.\hyperlink{classkernel__container_abcbec3854917b37bd6421b6b8ed2c2c0}{getInputQueue}().size() > 0 )
70       \{
71          \hyperlink{structsched__cmd__t}{sched\_cmd\_t} new\_cmd;
72          input\_buffer.pop< \hyperlink{structsched__cmd__t}{sched\_cmd\_t} >( new\_cmd );
73          \textcolor{keywordflow}{switch}( new\_cmd.\hyperlink{structsched__cmd__t_ab4ecf8a7b468db75074c0ba1493caac7}{cmd} )
74          \{
75             \textcolor{keywordflow}{case}( schedule::add ):
76             \{
77                assert( new\_cmd.\hyperlink{structsched__cmd__t_a8f78af789430b7661f52de7365abcdbc}{kernel} != \textcolor{keyword}{nullptr} );
78                \textcolor{comment}{//FIXME: hacked this so it'll compile, need to fix preempt state}
79                \textcolor{comment}{//const auto ret\_val( setPreemptState( new\_cmd.kernel ) );}
80                \textcolor{keyword}{const} \textcolor{keyword}{auto} ret\_val( 0 );
81                \textcolor{keywordflow}{switch}( ret\_val )
82                \{
83                   \textcolor{keywordflow}{case}( 0 \textcolor{comment}{/* newly scheduled kernel */} ):
84                   \{
85                      \textcolor{keywordtype}{bool} done( \textcolor{keyword}{false} );
86                      \textcolor{keyword}{auto} &out\_cmd( output\_buffer.allocate< \hyperlink{structsched__cmd__t}{sched\_cmd\_t} >() );
87                      \hyperlink{class_schedule_acf28b4a4231e693585751a035873615c}{Schedule::kernelRun}( new\_cmd.\hyperlink{structsched__cmd__t_a8f78af789430b7661f52de7365abcdbc}{kernel}, done );
88                      out\_cmd.cmd            = ( done ? schedule::kernelfinished : 
89                                                        schedule::reschedule );
90                      out\_cmd.kernel         = new\_cmd.\hyperlink{structsched__cmd__t_a8f78af789430b7661f52de7365abcdbc}{kernel};
91                      output\_buffer.send();\textcolor{comment}{}
92 \textcolor{comment}{                     /** clean-up buffer and recycle head of FIFO **/}
93                   \}
94                   \textcolor{keywordflow}{break};
95                   \textcolor{keywordflow}{case}( 1 \textcolor{comment}{/* kernel preempted */} ):
96                   \{
97                      container.preempted\_kernel\_pool.push( new\_cmd.\hyperlink{structsched__cmd__t_a8f78af789430b7661f52de7365abcdbc}{kernel} );
98                   \}
99                   \textcolor{keywordflow}{break};
100                   \textcolor{keywordflow}{default}:
101                      assert( \textcolor{keyword}{false} );
102                \}
103             \}
104             \textcolor{keywordflow}{break};
105             \textcolor{keywordflow}{case}( schedule::shutdown ):
106             \{\textcolor{comment}{}
107 \textcolor{comment}{               /** just in case, a sanity check here **/}
108                shutdown = \textcolor{keyword}{true};
109             \}
110             \textcolor{keywordflow}{break};
111             \textcolor{keywordflow}{default}:
112             \{
113                std::cerr << \textcolor{stringliteral}{"Invalid signal: "} << 
114                   schedule::sched\_cmd\_str[ new\_cmd.\hyperlink{structsched__cmd__t_ab4ecf8a7b468db75074c0ba1493caac7}{cmd} ] << \textcolor{stringliteral}{"\(\backslash\)n"};
115                assert( \textcolor{keyword}{false} );
116             \}
117          \}
118       \}\textcolor{comment}{}
119 \textcolor{comment}{      /** try these kernels again **/}
120       \textcolor{keywordflow}{if}( container.preempted\_kernel\_pool.size() > 0 )
121       \{
122          \textcolor{comment}{//auto * const kernel( container.preempted\_kernel\_pool.front() );}
123          container.preempted\_kernel\_pool.pop();
124          \textcolor{comment}{//restore( kernel );}\textcolor{comment}{}
125 \textcolor{comment}{         /** after this it'll longjmp to the running state **/} 
126       \}
127    \}
128 \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classkernel__container_a89f9b11119d9ab0e8c64215bf50856f0_cgraph}
\end{center}
\end{figure}
\hypertarget{classkernel__container_abcbec3854917b37bd6421b6b8ed2c2c0}{}\label{classkernel__container_abcbec3854917b37bd6421b6b8ed2c2c0} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!get\+Input\+Queue@{get\+Input\+Queue}}
\index{get\+Input\+Queue@{get\+Input\+Queue}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{get\+Input\+Queue()}{getInputQueue()}}
{\footnotesize\ttfamily kernel\+\_\+container\+::buffer \& kernel\+\_\+container\+::get\+Input\+Queue (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

get\+Input -\/ get input \hyperlink{class_f_i_f_o}{F\+I\+FO} \begin{DoxyReturn}{Returns}
buffer\& 
\end{DoxyReturn}


Definition at line 48 of file kernelcontainer.\+cpp.



Referenced by container\+\_\+run().


\begin{DoxyCode}
49 \{
50    assert( input\_buff != \textcolor{keyword}{nullptr} );
51    \textcolor{keywordflow}{return}( *input\_buff );
52 \}
\end{DoxyCode}
\hypertarget{classkernel__container_a64384e258fee9b664d164eb50baf33df}{}\label{classkernel__container_a64384e258fee9b664d164eb50baf33df} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!get\+Output\+Queue@{get\+Output\+Queue}}
\index{get\+Output\+Queue@{get\+Output\+Queue}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{get\+Output\+Queue()}{getOutputQueue()}}
{\footnotesize\ttfamily kernel\+\_\+container\+::buffer \& kernel\+\_\+container\+::get\+Output\+Queue (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

get\+Output\+Queue \begin{DoxyReturn}{Returns}
buffer\& 
\end{DoxyReturn}


Definition at line 55 of file kernelcontainer.\+cpp.



Referenced by container\+\_\+run().


\begin{DoxyCode}
56 \{
57    assert( output\_buff != \textcolor{keyword}{nullptr} );
58    \textcolor{keywordflow}{return}( *output\_buff );
59 \}
\end{DoxyCode}
\hypertarget{classkernel__container_a358a15b772f1b7dfa57bd733fc78fcaa}{}\label{classkernel__container_a358a15b772f1b7dfa57bd733fc78fcaa} 
\index{kernel\+\_\+container@{kernel\+\_\+container}!size@{size}}
\index{size@{size}!kernel\+\_\+container@{kernel\+\_\+container}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily std\+::size\+\_\+t kernel\+\_\+container\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

size -\/ returns the number of items currently scheduled for this container. \begin{DoxyReturn}{Returns}
std\+::size\+\_\+t, number of items 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
kernelcontainer.\+hpp\item 
kernelcontainer.\+cpp\end{DoxyCompactItemize}
