{"name":"Raft Light","tagline":"Simple, easy to use stream computation library for C++.","body":"### Welcome to the Raft Light C++ template library\r\nTo checkout the library do the following:\r\n```\r\n$ cd location_for_the_repo\r\n$ git clone git@github.com:jonathan-beard/RaftLight.git\r\n$ cd RaftLight\r\n$ git clone git@github.com:jonathan-beard/templatedLockFreeFIFOQueue.git -b dev fifo\r\n```\r\n\r\nNow you have all the files needed.  At the moment the system is in the beta phase, really designed\r\nfor research and hobby usage.  Eventually it'll have a proper build system.  At the moment \r\nhowever you'll have to do the following:\r\n```\r\n$ cd location_for_the_repo\r\n$ make\r\n```\r\nThis will generate the static library file _raftlight.a_.  Once this is built you're basically\r\nset save for a few details, which will be laid out within the tutorial as we build a simple\r\nexample.\r\n\r\n### Designer Templates\r\nWe've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.\r\n\r\n### Authors and Contributors\r\nIn 2013 Jonathan Beard (@jonathan-beard) started work on the Raft language.  In the interim,\r\nand realizing the ubiquity of the C++ language, he started work on a template library that \r\nuses the same framework as the full Raft language and run-time system.  This C++ library is \r\nthe result.\r\n\r\n### Genealogy\r\nThere have been several dozen streaming languages.  Most notable of which is probably StreaMIT.  I've worked on the Auto-Pipe streaming runtime system (both versions 1 and 2) developed at Washington University.  This particular streaming library was developed as a faster way to get started with stream processing by enabling users to stick to a language with which they are already familiar (C++).\r\n\r\n### Tutorial\r\nThe tutorial could be written two ways.  The first would be to enumerate all the possible functions and configurations.  The second would be to give an example and explain the example as it is presented.  We'll start with the example approach then move to a short directory of useful functions followed by some permutations on the previously mentioned example.\r\n\r\nFirst and foremost what is stream processing.  Essentially it is a compute paradigm that envisions perfectly safe, threaded programs (although we'll relax this a bit with locked shared objects, shown much later in the tutorial).  Stream programs themselves are decomposed into compute \"kernels\" which are connected by communications links called \"streams.\"  As an extremely simple example, take a look at the figure below which has three compute \"kernels\" (A,B,C) connected by two \"streams.\"\r\n\r\n![tandem queue](http://www.cse.wustl.edu/~beardj/queues.eps)\r\n\r\nAs a concrete example we have a \"sum\" application which generates a random stream of numbers from two separate threads, sums them in another and finally prints them in yet another thread.  Admittedly this is a bit wasteful in practice, however its a nice dirt simple example. \r\n\r\n```\r\n\r\n```","google":"UA-55176313-1","note":"Don't delete this file! It's used internally to help with page regeneration."}