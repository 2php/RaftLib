\hypertarget{class_allocate}{}\section{Allocate Class Reference}
\label{class_allocate}\index{Allocate@{Allocate}}
Inheritance diagram for Allocate\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_allocate}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_allocate_a61d8b01e404c23ead20068035e3ba540}{Allocate} (\hyperlink{class_map}{Map} \&map, volatile bool \&\hyperlink{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{exit\+\_\+alloc})
\item 
virtual \hyperlink{class_allocate_a68cd61da26f3b82da094b6d3e5d556f5}{$\sim$\+Allocate} ()
\item 
virtual void \hyperlink{class_allocate_a44f9b51c382fec159233609e21b9d272}{run} ()=0
\item 
void \hyperlink{class_allocate_a3123c2c1d9584974ce19b47fe6ceea17}{wait\+Till\+Ready} ()
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_allocate_a1d5c71b5cd6fc9671ed82d9c1d04965c}{initialize} (\hyperlink{struct_port_info}{Port\+Info} $\ast$const src, \hyperlink{struct_port_info}{Port\+Info} $\ast$const dst, F\+I\+F\+O $\ast$const fifo)
\item 
\hypertarget{class_allocate_a901eb0fdb6cffd56019c9ab9f2b25f92}{}virtual void {\bfseries allocate} (\hyperlink{struct_port_info}{Port\+Info} \&a, \hyperlink{struct_port_info}{Port\+Info} \&b, void $\ast$data)\label{class_allocate_a901eb0fdb6cffd56019c9ab9f2b25f92}

\item 
void \hyperlink{class_allocate_a4cf36bb704e43f5736a0e736d9e1a81b}{set\+Ready} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
kernelkeeper \& \hyperlink{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}{source\+\_\+kernels}
\item 
\hypertarget{class_allocate_a91e8c7d69ab7b309ea45439aea54fb4f}{}kernelkeeper \& {\bfseries all\+\_\+kernels}\label{class_allocate_a91e8c7d69ab7b309ea45439aea54fb4f}

\item 
std\+::set$<$ F\+I\+F\+O $\ast$ $>$ \hyperlink{class_allocate_a037410210c0d10578f87de1ec68f47ba}{allocated\+\_\+fifo}
\item 
volatile bool \& \hyperlink{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{exit\+\_\+alloc}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_allocate_a901ac6fe1c35f3c114cf9e83f75dde0c}{}class {\bfseries basic\+\_\+parallel}\label{class_allocate_a901ac6fe1c35f3c114cf9e83f75dde0c}

\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_allocate_a61d8b01e404c23ead20068035e3ba540}{}\index{Allocate@{Allocate}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!Allocate@{Allocate}}
\subsubsection[{Allocate(\+Map \&map, volatile bool \&exit\+\_\+alloc)}]{\setlength{\rightskip}{0pt plus 5cm}Allocate\+::\+Allocate (
\begin{DoxyParamCaption}
\item[{{\bf Map} \&}]{map, }
\item[{volatile bool \&}]{exit\+\_\+alloc}
\end{DoxyParamCaption}
)}\label{class_allocate_a61d8b01e404c23ead20068035e3ba540}
\hyperlink{class_allocate}{Allocate} -\/ base constructor, really doesn\textquotesingle{}t do too much save for setting the global variables all\+\_\+kernels and source\+\_\+kernels from the \hyperlink{class_map}{Map} object. 
\begin{DoxyParams}{Parameters}
{\em map} & -\/ \hyperlink{class_map}{Map}\& \\
\hline
{\em exit\+\_\+alloc} & -\/ bool used to terminate loop, for monitoring allocations, controlled by map object.\\
\hline
\end{DoxyParams}
allocate.\+cpp -\/ \begin{DoxyAuthor}{Author}
\+: Jonathan Beard 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
\+: Tue Sep 16 20\+:20\+:06 2014
\end{DoxyVersion}
Copyright 2014 Jonathan Beard

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at\+:

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+I\+S, W\+I\+T\+H\+O\+U\+T W\+A\+R\+R\+A\+N\+T\+I\+E\+S O\+R C\+O\+N\+D\+I\+T\+I\+O\+N\+S O\+F A\+N\+Y K\+I\+N\+D, either express or implied. See the License for the specific language governing permissions and limitations under the License. \hypertarget{class_allocate_a68cd61da26f3b82da094b6d3e5d556f5}{}\index{Allocate@{Allocate}!````~Allocate@{$\sim$\+Allocate}}
\index{````~Allocate@{$\sim$\+Allocate}!Allocate@{Allocate}}
\subsubsection[{$\sim$\+Allocate()}]{\setlength{\rightskip}{0pt plus 5cm}Allocate\+::$\sim$\+Allocate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{class_allocate_a68cd61da26f3b82da094b6d3e5d556f5}
destructor 

\subsection{Member Function Documentation}
\hypertarget{class_allocate_a1d5c71b5cd6fc9671ed82d9c1d04965c}{}\index{Allocate@{Allocate}!initialize@{initialize}}
\index{initialize@{initialize}!Allocate@{Allocate}}
\subsubsection[{initialize(\+Port\+Info $\ast$const src, Port\+Info $\ast$const dst, F\+I\+F\+O $\ast$const fifo)}]{\setlength{\rightskip}{0pt plus 5cm}void Allocate\+::initialize (
\begin{DoxyParamCaption}
\item[{{\bf Port\+Info} $\ast$const}]{src, }
\item[{{\bf Port\+Info} $\ast$const}]{dst, }
\item[{F\+I\+F\+O $\ast$const}]{fifo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{class_allocate_a1d5c71b5cd6fc9671ed82d9c1d04965c}
initialize -\/ internal method to be used within the run method takes care of the initialization using the already allocated F\+I\+F\+O object passed as a param. This function will throw an exception if either port (src or dst) have already been allocated. 
\begin{DoxyParams}{Parameters}
{\em src} & -\/ Port\+Info$\ast$, nullptr if not to be set \\
\hline
{\em dst} & -\/ Port\+Info$\ast$, nullptr if not to be set \\
\hline
{\em fifo} & -\/ F\+I\+F\+O$\ast$ \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{class_port_double_initialize_exception}{Port\+Double\+Initialize\+Exception}} & -\/ if either port is already initialized. \\
\hline
\end{DoxyExceptions}
N\+O\+T\+E\+: this list simply speeds up the monitoring if we want it \hypertarget{class_allocate_a44f9b51c382fec159233609e21b9d272}{}\index{Allocate@{Allocate}!run@{run}}
\index{run@{run}!Allocate@{Allocate}}
\subsubsection[{run()=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual void Allocate\+::run (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\label{class_allocate_a44f9b51c382fec159233609e21b9d272}
run -\/ implement this function to create a new allocator, will be run inside a thread so exits when done but if run-\/time monitoring is desired then this is the place to do it. 

Implemented in \hyperlink{classstdalloc_a60438b15948ce354b52b03ba6d975de0}{stdalloc}, and \hyperlink{classdynalloc_a2a52b86ec09bd6dd52e49062137b2e37}{dynalloc}.

\hypertarget{class_allocate_a4cf36bb704e43f5736a0e736d9e1a81b}{}\index{Allocate@{Allocate}!set\+Ready@{set\+Ready}}
\index{set\+Ready@{set\+Ready}!Allocate@{Allocate}}
\subsubsection[{set\+Ready()}]{\setlength{\rightskip}{0pt plus 5cm}void Allocate\+::set\+Ready (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{class_allocate_a4cf36bb704e43f5736a0e736d9e1a81b}
set\+Ready -\/ call within the implemented run function to signal that the initial allocations have been completed. \hypertarget{class_allocate_a3123c2c1d9584974ce19b47fe6ceea17}{}\index{Allocate@{Allocate}!wait\+Till\+Ready@{wait\+Till\+Ready}}
\index{wait\+Till\+Ready@{wait\+Till\+Ready}!Allocate@{Allocate}}
\subsubsection[{wait\+Till\+Ready()}]{\setlength{\rightskip}{0pt plus 5cm}void Allocate\+::wait\+Till\+Ready (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_allocate_a3123c2c1d9584974ce19b47fe6ceea17}
wait\+Till\+Ready -\/ call after initializing the allocate thread, returns when the initial allocation is complete. 

\subsection{Member Data Documentation}
\hypertarget{class_allocate_a037410210c0d10578f87de1ec68f47ba}{}\index{Allocate@{Allocate}!allocated\+\_\+fifo@{allocated\+\_\+fifo}}
\index{allocated\+\_\+fifo@{allocated\+\_\+fifo}!Allocate@{Allocate}}
\subsubsection[{allocated\+\_\+fifo}]{\setlength{\rightskip}{0pt plus 5cm}std\+::set$<$ F\+I\+F\+O$\ast$ $>$ Allocate\+::allocated\+\_\+fifo\hspace{0.3cm}{\ttfamily [protected]}}\label{class_allocate_a037410210c0d10578f87de1ec68f47ba}
keeps a list of all currently allocated F\+I\+F\+O objects, set from within the initialize function. \hypertarget{class_allocate_a4d10076b88ab1297c89b8a05e117b510}{}\index{Allocate@{Allocate}!exit\+\_\+alloc@{exit\+\_\+alloc}}
\index{exit\+\_\+alloc@{exit\+\_\+alloc}!Allocate@{Allocate}}
\subsubsection[{exit\+\_\+alloc}]{\setlength{\rightskip}{0pt plus 5cm}volatile bool\& Allocate\+::exit\+\_\+alloc\hspace{0.3cm}{\ttfamily [protected]}}\label{class_allocate_a4d10076b88ab1297c89b8a05e117b510}
exit\+\_\+alloc -\/ bool whose value is set by the map object, controls when the loop within the alloc thread is exited. \hypertarget{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}{}\index{Allocate@{Allocate}!source\+\_\+kernels@{source\+\_\+kernels}}
\index{source\+\_\+kernels@{source\+\_\+kernels}!Allocate@{Allocate}}
\subsubsection[{source\+\_\+kernels}]{\setlength{\rightskip}{0pt plus 5cm}kernelkeeper\& Allocate\+::source\+\_\+kernels\hspace{0.3cm}{\ttfamily [protected]}}\label{class_allocate_a93e612d7ea7eb686fc88b5dee7a1407b}
both convenience structs, hold exactly what the names say 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
allocate.\+hpp\item 
allocate.\+cpp\end{DoxyCompactItemize}
