\hypertarget{class_schedule}{}\section{Schedule Class Reference}
\label{class_schedule}\index{Schedule@{Schedule}}
Inheritance diagram for Schedule\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_schedule}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_schedule_ad88c01f0ebf0c2f3bfa3ca2fe7ca3e8f}{Schedule} (\hyperlink{class_map}{Map} \&map)
\item 
virtual \hyperlink{class_schedule_a4806b985197d35c00b9e707c0ed87998}{$\sim$\+Schedule} ()
\item 
virtual void \hyperlink{class_schedule_ab6ad5540ecdef6b472b4e8242a47c4ee}{start} ()=0
\item 
virtual void \hyperlink{class_schedule_a5180032a0c2135507859ccf2a4eea1ab}{init} ()
\item 
void \hyperlink{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641}{schedule\+Kernel} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{class_schedule_acf28b4a4231e693585751a035873615c}{kernel\+Run} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel, volatile bool \&finished, jmp\+\_\+buf $\ast$gotostate=nullptr, jmp\+\_\+buf $\ast$kernel\+\_\+state=nullptr)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_schedule_addff3f2e72caab274963cc888faa2f6b}{}virtual void {\bfseries handle\+Schedule} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel)=0\label{class_schedule_addff3f2e72caab274963cc888faa2f6b}

\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static raft\+::kstatus \hyperlink{class_schedule_a85de3d48407aa378ccc86a4a4206b32a}{check\+System\+Signal} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const kernel, void $\ast$data, \hyperlink{class_system_signal_handler}{System\+Signal\+Handler} \&\hyperlink{class_schedule_ad248e99611a87776fb411836cd46a603}{handlers})
\item 
static raft\+::kstatus \hyperlink{class_schedule_a5167d622689a34ea5f3a065304295521}{quit\+Handler} (F\+I\+F\+O \&fifo, \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel, const raft\+::signal signal, void $\ast$data)
\item 
\hypertarget{class_schedule_a3bf10fd9419c58849d7be98336dc0aff}{}static void {\bfseries invalidate\+Output\+Ports} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel)\label{class_schedule_a3bf10fd9419c58849d7be98336dc0aff}

\item 
static bool \hyperlink{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{kernel\+Has\+Input\+Data} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel)
\item 
static bool \hyperlink{class_schedule_a2e2035e0c0666054f8401ad2b3792854}{kernel\+Has\+No\+Input\+Ports} (\hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$kernel)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_system_signal_handler}{System\+Signal\+Handler} \hyperlink{class_schedule_ad248e99611a87776fb411836cd46a603}{handlers}
\item 
kernelkeeper \& \hyperlink{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}{kernel\+\_\+set}
\item 
\hypertarget{class_schedule_ad4c895eb77d8287a9a19215cced7af7b}{}kernelkeeper \& {\bfseries source\+\_\+kernels}\label{class_schedule_ad4c895eb77d8287a9a19215cced7af7b}

\item 
\hypertarget{class_schedule_aebf2c26334eae760032d82a016898043}{}kernelkeeper \& {\bfseries dst\+\_\+kernels}\label{class_schedule_aebf2c26334eae760032d82a016898043}

\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_schedule_ad88c01f0ebf0c2f3bfa3ca2fe7ca3e8f}{}\index{Schedule@{Schedule}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!Schedule@{Schedule}}
\subsubsection[{Schedule(\+Map \&map)}]{\setlength{\rightskip}{0pt plus 5cm}Schedule\+::\+Schedule (
\begin{DoxyParamCaption}
\item[{{\bf Map} \&}]{map}
\end{DoxyParamCaption}
)}\label{class_schedule_ad88c01f0ebf0c2f3bfa3ca2fe7ca3e8f}
\hyperlink{class_schedule}{Schedule} -\/ base constructor takes a map object so that all sub-\/classes can access some of the map features through the schedule sub-\/class accessors. 
\begin{DoxyParams}{Parameters}
{\em map} & -\/ \hyperlink{class_map}{Map}\& \\
\hline
\end{DoxyParams}
\hypertarget{class_schedule_a4806b985197d35c00b9e707c0ed87998}{}\index{Schedule@{Schedule}!````~Schedule@{$\sim$\+Schedule}}
\index{````~Schedule@{$\sim$\+Schedule}!Schedule@{Schedule}}
\subsubsection[{$\sim$\+Schedule()}]{\setlength{\rightskip}{0pt plus 5cm}Schedule\+::$\sim$\+Schedule (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{class_schedule_a4806b985197d35c00b9e707c0ed87998}
destructor, takes care of cleanup nothing to do at the moment 

\subsection{Member Function Documentation}
\hypertarget{class_schedule_a85de3d48407aa378ccc86a4a4206b32a}{}\index{Schedule@{Schedule}!check\+System\+Signal@{check\+System\+Signal}}
\index{check\+System\+Signal@{check\+System\+Signal}!Schedule@{Schedule}}
\subsubsection[{check\+System\+Signal(raft\+::kernel $\ast$const kernel, void $\ast$data, System\+Signal\+Handler \&handlers)}]{\setlength{\rightskip}{0pt plus 5cm}raft\+::kstatus Schedule\+::check\+System\+Signal (
\begin{DoxyParamCaption}
\item[{{\bf raft\+::kernel} $\ast$const}]{kernel, }
\item[{void $\ast$}]{data, }
\item[{{\bf System\+Signal\+Handler} \&}]{handlers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\label{class_schedule_a85de3d48407aa378ccc86a4a4206b32a}
check\+System\+Signal -\/ check the incomming streams for the param kernel for any system signals, if there is one then consume the signal and perform the appropriate action. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} \\
\hline
{\em data} & -\/ void$\ast$, use this if any further info is needed in future implementations of handlers \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
raft\+::kstatus, proceed unless a stop signal is received 
\end{DoxyReturn}
T\+O\+D\+O, right now there is special behavior for term signal only, what should we do with others? Need to decide that.\hypertarget{class_schedule_a5180032a0c2135507859ccf2a4eea1ab}{}\index{Schedule@{Schedule}!init@{init}}
\index{init@{init}!Schedule@{Schedule}}
\subsubsection[{init()}]{\setlength{\rightskip}{0pt plus 5cm}void Schedule\+::init (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{class_schedule_a5180032a0c2135507859ccf2a4eea1ab}
init -\/ call to pre-\/process all kernels, this function is called by the map object befure calling start. default, do nothing \hypertarget{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{}\index{Schedule@{Schedule}!kernel\+Has\+Input\+Data@{kernel\+Has\+Input\+Data}}
\index{kernel\+Has\+Input\+Data@{kernel\+Has\+Input\+Data}!Schedule@{Schedule}}
\subsubsection[{kernel\+Has\+Input\+Data(raft\+::kernel $\ast$kernel)}]{\setlength{\rightskip}{0pt plus 5cm}bool Schedule\+::kernel\+Has\+Input\+Data (
\begin{DoxyParamCaption}
\item[{{\bf raft\+::kernel} $\ast$}]{kernel}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\label{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}
kernel\+Has\+Input\+Data -\/ check each input port for available data, returns true if any of the input ports has available data. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool -\/ true if input data available. 
\end{DoxyReturn}
only output ports, keep calling till exits \hypertarget{class_schedule_a2e2035e0c0666054f8401ad2b3792854}{}\index{Schedule@{Schedule}!kernel\+Has\+No\+Input\+Ports@{kernel\+Has\+No\+Input\+Ports}}
\index{kernel\+Has\+No\+Input\+Ports@{kernel\+Has\+No\+Input\+Ports}!Schedule@{Schedule}}
\subsubsection[{kernel\+Has\+No\+Input\+Ports(raft\+::kernel $\ast$kernel)}]{\setlength{\rightskip}{0pt plus 5cm}bool Schedule\+::kernel\+Has\+No\+Input\+Ports (
\begin{DoxyParamCaption}
\item[{{\bf raft\+::kernel} $\ast$}]{kernel}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\label{class_schedule_a2e2035e0c0666054f8401ad2b3792854}
kernel\+Has\+No\+Input\+Ports -\/ pretty much exactly like the function name says, if the param kernel has no valid input ports (this function assumes that \hyperlink{class_schedule_ac23de3dd63554401fd0d8d23b60eecfa}{kernel\+Has\+Input\+Data()} has been called and returns false before this function is called) then it returns true.  kernel -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \begin{DoxyReturn}{Returns}
bool -\/ true if no valid input ports avail 
\end{DoxyReturn}
assume data check is already complete \hypertarget{class_schedule_acf28b4a4231e693585751a035873615c}{}\index{Schedule@{Schedule}!kernel\+Run@{kernel\+Run}}
\index{kernel\+Run@{kernel\+Run}!Schedule@{Schedule}}
\subsubsection[{kernel\+Run(raft\+::kernel $\ast$const kernel, volatile bool \&finished, jmp\+\_\+buf $\ast$gotostate=nullptr, jmp\+\_\+buf $\ast$kernel\+\_\+state=nullptr)}]{\setlength{\rightskip}{0pt plus 5cm}bool Schedule\+::kernel\+Run (
\begin{DoxyParamCaption}
\item[{{\bf raft\+::kernel} $\ast$const}]{kernel, }
\item[{volatile bool \&}]{finished, }
\item[{jmp\+\_\+buf $\ast$}]{gotostate = {\ttfamily nullptr}, }
\item[{jmp\+\_\+buf $\ast$}]{kernel\+\_\+state = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_schedule_acf28b4a4231e693585751a035873615c}
kernel\+Run -\/ all the logic necessary to run a single kernel successfully. Any additional signal handling should be handled by this function as its the only one that will be universally called by the scheduler. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel} $\ast$const object, non-\/null kernel \\
\hline
{\em finished} & -\/ volatile bool -\/ function sets to true when done. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if run with no need for jmp\+\_\+buf, false if the scheduler needs to run again with the kernel\+\_\+state 
\end{DoxyReturn}
must recheck data items again after port valid check, there could have been a push between these two conditional statements.\hypertarget{class_schedule_a5167d622689a34ea5f3a065304295521}{}\index{Schedule@{Schedule}!quit\+Handler@{quit\+Handler}}
\index{quit\+Handler@{quit\+Handler}!Schedule@{Schedule}}
\subsubsection[{quit\+Handler(\+F\+I\+F\+O \&fifo, raft\+::kernel $\ast$kernel, const raft\+::signal signal, void $\ast$data)}]{\setlength{\rightskip}{0pt plus 5cm}raft\+::kstatus Schedule\+::quit\+Handler (
\begin{DoxyParamCaption}
\item[{F\+I\+F\+O \&}]{fifo, }
\item[{{\bf raft\+::kernel} $\ast$}]{kernel, }
\item[{const raft\+::signal}]{signal, }
\item[{void $\ast$}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\label{class_schedule_a5167d622689a34ea5f3a065304295521}
quite\+Handler -\/ performs the actions needed when a port sends a quite signal (normal termination), this is most likely due to the end of data. 
\begin{DoxyParams}{Parameters}
{\em fifo} & -\/ F\+I\+F\+O\& that sent the signal \\
\hline
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \\
\hline
{\em signal} & -\/ raft\+::signal \\
\hline
{\em data} & -\/ void$\ast$, vain attempt to future proof \\
\hline
\end{DoxyParams}
N\+O\+T\+E\+: This should be the only action needed currently, however that may change in the futre with more features and systems added.\hypertarget{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641}{}\index{Schedule@{Schedule}!schedule\+Kernel@{schedule\+Kernel}}
\index{schedule\+Kernel@{schedule\+Kernel}!Schedule@{Schedule}}
\subsubsection[{schedule\+Kernel(raft\+::kernel $\ast$const kernel)}]{\setlength{\rightskip}{0pt plus 5cm}void Schedule\+::schedule\+Kernel (
\begin{DoxyParamCaption}
\item[{{\bf raft\+::kernel} $\ast$const}]{kernel}
\end{DoxyParamCaption}
)}\label{class_schedule_a6a722f6e76c8b8dc67874d9974b6d641}
schedule\+Kernel -\/ adds the kernel \char`\"{}kernel\char`\"{} to the schedule, ensures that it is run. Other than that there are no guarantees for its execution. It is purely virtual in its implementation. Before you drop in a kernel, it better be ready to go..all allocations should be complete. 
\begin{DoxyParams}{Parameters}
{\em kernel} & -\/ \hyperlink{classraft_1_1kernel}{raft\+::kernel}$\ast$ \\
\hline
\end{DoxyParams}
N\+O\+T\+E\+: The kernel param should be ready to rock, we just need to add it here. The data structures xx\+\_\+kernels all expect a fully ready kernel, well the threads monitoring the system do at least and this is one. What we need to do to kick off the execution is add it to the handle\+Schedule virtual function which is implemented by each scheduler.\hypertarget{class_schedule_ab6ad5540ecdef6b472b4e8242a47c4ee}{}\index{Schedule@{Schedule}!start@{start}}
\index{start@{start}!Schedule@{Schedule}}
\subsubsection[{start()=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual void Schedule\+::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\label{class_schedule_ab6ad5540ecdef6b472b4e8242a47c4ee}
start -\/ called to start execution of all kernels. Implementation specific so it is purely virtual. 

Implemented in \hyperlink{classpool__schedule_ab67558a44404e42ba032f799c0f424a7}{pool\+\_\+schedule}, and \hyperlink{classsimple__schedule_ad60a7608111e011d0c04f6ac566cfd8c}{simple\+\_\+schedule}.



\subsection{Member Data Documentation}
\hypertarget{class_schedule_ad248e99611a87776fb411836cd46a603}{}\index{Schedule@{Schedule}!handlers@{handlers}}
\index{handlers@{handlers}!Schedule@{Schedule}}
\subsubsection[{handlers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf System\+Signal\+Handler} Schedule\+::handlers\hspace{0.3cm}{\ttfamily [protected]}}\label{class_schedule_ad248e99611a87776fb411836cd46a603}
signal handlers \hypertarget{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}{}\index{Schedule@{Schedule}!kernel\+\_\+set@{kernel\+\_\+set}}
\index{kernel\+\_\+set@{kernel\+\_\+set}!Schedule@{Schedule}}
\subsubsection[{kernel\+\_\+set}]{\setlength{\rightskip}{0pt plus 5cm}kernelkeeper\& Schedule\+::kernel\+\_\+set\hspace{0.3cm}{\ttfamily [protected]}}\label{class_schedule_a1a448b0d48e656f94db65a70cedd8eed}
kernel set 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
schedule.\+hpp\item 
schedule.\+cpp\end{DoxyCompactItemize}
