<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="keywords" content="data flow programming, data flow library, data flow, c++ stream processing, RaftLight,Raft,C++,stream,stream processing, streaming computation, StreaMIT,Auto-Pipe,ScalaPipe,AutoPipe,Parallel,Safe"/>
    <meta name="description" content="Simple, easy to use stream computation library for C++">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Raft Light by jonathan-beard</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Raft Light</h1>
        <h2>Simple, easy to use stream computation library for C++.</h2>
        <center>
        <section id="downloads">
          <a href="https://github.com/jonathan-beard/RaftLight/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/jonathan-beard/RaftLight/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/jonathan-beard/RaftLight" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      
        <section id="downloads">
          <a href="#what" class="btn">Intro</a>
          <a href="#setup" class="btn">Setup</a>
          <a href="#tutorial" class="btn">Tutorial</a>
        </section>
        </center>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a name="welcome-to-the-raft-light-c-template-library" class="anchor" href="#welcome-to-the-raft-light-c-template-library"><span class="octicon octicon-link"></span></a>Welcome to the Raft Light C++ template library</h3>
<h3>
  <a name="what" class="anchor" href="#what"><span class="octicon octicon-link"></span></a>What is it?
</h3>

<p>
  RaftLight is a C++ template library version of the full Raft language.  It enables easy use of the stream
  processing compute paradigm (see: <a href="http://en.wikipedia.org/wiki/Stream_processing">link</a>).  The
  programmer can create safe, parallel programs without knowledge of threads or locks by composing compute 
  kernels into a larger application connected by lock free queues.  It is completely self contained, the 
  bulk of the code is compiled into a single static library, the rest is included within a single header file
  to be included within an application.
</p>

<h3>
<a name="current-status" class="anchor" href="#current-status"><span class="octicon octicon-link"></span></a>Current Status</h3>

<p>The RaftLight library is currently an alpha release.  The API itself is stable, however the back end
is subject to updates.  The release is subject to the Apache Version 2.0 license.  The current "master" branch has been built on Linux and OS X machines using gcc 4.8+, icc14.04 and clang 3.5+.  The OS X version of clang++ has issues with handling of dependent template names (i.e., the allocate call), on OS X either use icc or build the latest version of either clang or gcc from source.</p>

<h3>
<a name="setup" class="anchor" href="#setup"><span class="octicon octicon-link"></span></a>Setup</h3>

<p>To checkout the library do the following:</p>

<pre><code>$ cd location_for_the_repo
$ git clone git@github.com:jonathan-beard/RaftLight.git
$ cd RaftLight
$ make
$ sudo make install
</code></pre>

<p>This will generate the static library file <em>raftlight.a</em>.  When building an application
using the library the only header file needed is the <em>raft</em> header.  Once the library
is build you're basically set save for a few details, which will be laid out within the tutorial
 as we go through the example we're about to build.</p>

<p>To build the example application simply:</p>

<pre><code>$ cd RaftLight/ExampleApps
$ make
</code></pre>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>In 2013 Jonathan Beard (<a href="https://github.com/jonathan-beard" class="user-mention">@jonathan-beard</a>) started work on the Raft language.  In the interim,
and realizing the ubiquity of the C++ language, he started work on a template library that 
uses the same framework as the full Raft language and run-time system.  This C++ library is 
the result.</p>

<h3>
<a name="genealogy" class="anchor" href="#genealogy"><span class="octicon octicon-link"></span></a>Genealogy</h3>

<p>There have been several dozen streaming languages.  Most notable of which is probably StreaMIT.  I've worked on the Auto-Pipe streaming runtime system (both versions 1 and 2) developed at Washington University.  This particular streaming library was developed as a faster way to get started with stream processing by enabling users to stick to a language with which they are already familiar (C++).</p>

<h3>
<a name="tutorial" class="anchor" href="#tutorial"><span class="octicon octicon-link"></span></a>Tutorial</h3>

<p>The tutorial could be written two ways.  The first would be to enumerate all the possible functions and configurations.  The second would be to give an example and explain the example as it is presented.  We'll start with the example approach then move to a short directory of useful functions followed by some permutations on the previously mentioned example.</p>

<p>First and foremost what is stream processing?  Essentially it is a compute paradigm that envisions perfectly safe, threaded programs (although we'll relax this a bit with locked shared objects, shown much later in the tutorial).  Stream programs themselves are decomposed into compute "kernels" which are connected by communications links called "streams."  As an extremely simple example, take a look at the figure below which has three compute "kernels" (A,B,C) connected by two "streams."</p>

<p><img src="http://www.cse.wustl.edu/%7Ebeardj/queues.jpg" alt="tandem queue"/></p>

<p>As a concrete example we have a "sum" application (application topology shown below) which generates a random stream of numbers from two separate threads, sums them in another and finally prints them in yet another thread.  Admittedly this is a bit wasteful in practice, however it is a nice dirt simple example. </p>

<p><img src="http://www.cse.wustl.edu/%7Ebeardj/sum.jpg" alt="sum app"/></p>

<div class="highlight highlight-c++"><pre><span class="cp">#include &lt;cassert&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;cstdint&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cm">/** include the raft header file **/</span>
<span class="cp">#include &lt;raft&gt;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Generate</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Kernel</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Generate</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1000</span> <span class="p">)</span> <span class="o">:</span> <span class="n">Kernel</span><span class="p">(),</span>
                                          <span class="n">count</span><span class="p">(</span> <span class="n">count</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="n">output</span><span class="p">.</span><span class="n">addPort</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;</span><span class="p">(</span> <span class="s">"number_stream"</span> <span class="p">);</span>
   <span class="p">}</span>

   <span class="k">virtual</span> <span class="n">raft</span><span class="o">::</span><span class="n">kstatus</span> <span class="n">run</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span>
      <span class="p">{</span>
         <span class="n">output</span><span class="p">[</span> <span class="s">"number_stream"</span> <span class="p">].</span><span class="n">push</span><span class="p">(</span> <span class="n">count</span> <span class="p">);</span>
         <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">proceed</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="n">output</span><span class="p">[</span> <span class="s">"number_stream"</span> <span class="p">].</span><span class="n">push</span><span class="p">(</span> <span class="n">count</span><span class="p">,</span> <span class="n">raft</span><span class="o">::</span><span class="n">eof</span> <span class="p">);</span>
      <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">stop</span> <span class="p">);</span>
   <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Sum</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Kernel</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Sum</span><span class="p">()</span> <span class="o">:</span> <span class="n">Kernel</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="n">input</span><span class="p">.</span><span class="n">addPort</span><span class="o">&lt;</span> <span class="n">A</span> <span class="o">&gt;</span><span class="p">(</span> <span class="s">"input_a"</span> <span class="p">);</span>
      <span class="n">input</span><span class="p">.</span><span class="n">addPort</span><span class="o">&lt;</span> <span class="n">B</span> <span class="o">&gt;</span><span class="p">(</span> <span class="s">"input_b"</span> <span class="p">);</span>
      <span class="n">output</span><span class="p">.</span><span class="n">addPort</span><span class="o">&lt;</span> <span class="n">C</span>  <span class="o">&gt;</span><span class="p">(</span> <span class="s">"sum"</span> <span class="p">);</span>
   <span class="p">}</span>

   <span class="k">virtual</span> <span class="n">raft</span><span class="o">::</span><span class="n">kstatus</span> <span class="n">run</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
      <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
      <span class="n">raft</span><span class="o">::</span><span class="n">signal</span>  <span class="n">sig_a</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">none</span>  <span class="p">),</span> <span class="n">sig_b</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">none</span> <span class="p">);</span>
      <span class="n">input</span><span class="p">[</span> <span class="s">"input_a"</span> <span class="p">].</span><span class="n">pop</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig_a</span> <span class="p">);</span>
      <span class="n">input</span><span class="p">[</span> <span class="s">"input_b"</span> <span class="p">].</span><span class="n">pop</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig_b</span> <span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span> <span class="n">sig_a</span> <span class="o">==</span> <span class="n">sig_b</span> <span class="p">);</span>
      <span class="n">C</span> <span class="nf">c</span><span class="p">(</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">);</span>
      <span class="n">output</span><span class="p">[</span> <span class="s">"sum"</span> <span class="p">].</span><span class="n">push</span><span class="p">(</span> <span class="n">c</span> <span class="p">,</span> <span class="n">sig_a</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">sig_b</span> <span class="o">==</span> <span class="n">raft</span><span class="o">::</span><span class="n">eof</span> <span class="p">)</span>
      <span class="p">{</span>
         <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">stop</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">proceed</span> <span class="p">);</span>
   <span class="p">}</span>

<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Print</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Kernel</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">Print</span><span class="p">()</span> <span class="o">:</span> <span class="n">Kernel</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="n">input</span><span class="p">.</span><span class="n">addPort</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;</span><span class="p">(</span> <span class="s">"in"</span> <span class="p">);</span>
   <span class="p">}</span>

   <span class="k">virtual</span> <span class="n">raft</span><span class="o">::</span><span class="n">kstatus</span> <span class="n">run</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
      <span class="n">raft</span><span class="o">::</span><span class="n">signal</span>  <span class="n">signal</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">none</span> <span class="p">);</span>
      <span class="n">input</span><span class="p">[</span> <span class="s">"in"</span> <span class="p">].</span><span class="n">pop</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">signal</span> <span class="p">);</span>
      <span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"%"</span> <span class="n">PRIu64</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span> <span class="p">);</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">signal</span> <span class="o">==</span> <span class="n">raft</span><span class="o">::</span><span class="n">eof</span> <span class="p">)</span>
      <span class="p">{</span>
         <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">stop</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">proceed</span> <span class="p">);</span>
   <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">Map</span> <span class="n">map</span><span class="p">;</span>
   <span class="k">auto</span> <span class="n">linked_kernels</span><span class="p">(</span> <span class="n">map</span><span class="p">.</span><span class="n">link</span><span class="p">(</span> <span class="k">new</span> <span class="n">Generate</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">(),</span>
                                  <span class="k">new</span> <span class="n">Sum</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">(),</span>
                                  <span class="s">"input_a"</span> <span class="p">)</span> <span class="p">);</span>
   <span class="n">map</span><span class="p">.</span><span class="n">link</span><span class="p">(</span> <span class="k">new</span> <span class="n">Generate</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">(),</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">linked_kernels</span><span class="p">.</span><span class="n">dst</span> <span class="p">),</span> <span class="s">"input_b"</span> <span class="p">);</span>
   <span class="n">map</span><span class="p">.</span><span class="n">link</span><span class="p">(</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">linked_kernels</span><span class="p">.</span><span class="n">dst</span> <span class="p">),</span> <span class="k">new</span> <span class="n">Print</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
   <span class="n">map</span><span class="p">.</span><span class="n">exe</span><span class="p">();</span>
   <span class="k">return</span><span class="p">(</span> <span class="n">EXIT_SUCCESS</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>The first thing to notice is that all compute kernels extend the class Kernel.  This sets up the "ports"
that exist for communication between compute kernels.  For each kernel there are multiple ports.  Input
ports and output ports for each kernel are maintained in a data structure of that name.  When designing 
a new kernel, the constructor must declare all ports as such:</p>

<div class="highlight highlight-c++"><pre>   <span class="p">[</span><span class="n">input</span> <span class="o">|</span> <span class="n">output</span><span class="p">].</span><span class="n">addPort</span><span class="o">&lt;</span> <span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">&gt;</span><span class="p">(</span> <span class="p">[</span><span class="n">port</span> <span class="n">name</span><span class="p">]</span> <span class="p">);</span>
</pre></div>

<p>This has two effects, the first registering a type with the port to ensure type safety, and the second
registering a port with a name so that it can be quickly accessed later.  These ports are constructed
as lock free first in, first out buffers or "ring-buffers" which enable communication.  The run-time
system decides on how big the buffer should be and has the option of dynamically monitoring the buffer
to adjust the size at run-time.  Once ports are declared within the constructor the second function that
must be declared is <em>run()</em>.  It performs the main work of the kernel, although sub-functions can be 
declared to compartmentalize code.  As an example:</p>

<div class="highlight highlight-c++"><pre>   <span class="k">virtual</span> <span class="n">raft</span><span class="o">::</span><span class="n">kstatus</span> <span class="n">run</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="p">[</span> <span class="n">some</span> <span class="kt">bool</span> <span class="n">here</span> <span class="p">]</span> <span class="p">)</span>
      <span class="p">{</span>
         <span class="n">output</span><span class="p">[</span> <span class="s">"the_port"</span> <span class="p">].</span><span class="n">push</span><span class="p">(</span> <span class="n">count</span> <span class="p">);</span>
         <span class="cm">/** return raft::proceed to get called again **/</span>
         <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">proceed</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="cm">/** else **/</span>
      <span class="cm">/** </span>
<span class="cm">       * call push with the last item and send a signal that will terminate</span>
<span class="cm">       * the application such as raft::eof</span>
<span class="cm">       */</span>
      <span class="n">output</span><span class="p">[</span> <span class="s">"the_port"</span> <span class="p">].</span><span class="n">push</span><span class="p">(</span> <span class="n">count</span><span class="p">,</span> <span class="n">raft</span><span class="o">::</span><span class="n">eof</span> <span class="p">);</span>
      <span class="cm">/** return raft::stop to end the calling of this kernel **/</span>
      <span class="k">return</span><span class="p">(</span> <span class="n">raft</span><span class="o">::</span><span class="n">stop</span> <span class="p">);</span>
   <span class="p">}</span>
</pre></div>

<p>The run function can be executed in a separate thread or in it's own process depending 
on how the scheduler schedules it.  In either case, it will be called until it returns
raft::stop, otherwise raft::proceed should be returned.  Otherwise there is nothing
really special about the Kernel class.  In future tutorials I'll add an example of how
the RaftLight library system an be used with OpenCL with the queue talking directly to
a kernel running on a GPU.  GPU kernels will have a slightly differing structure, but 
from the programmers perspective will have similar port semantics as the C++ kernels.</p>

<p>To "hook" compute kernels together we need a "Map" object, as in the following example (shamelessly taken
from the above "sum" example):</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">Map</span> <span class="n">map</span><span class="p">;</span>
   <span class="k">auto</span> <span class="n">linked_kernels</span><span class="p">(</span> <span class="n">map</span><span class="p">.</span><span class="n">link</span><span class="p">(</span> <span class="k">new</span> <span class="n">Generate</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">(),</span>
                                  <span class="k">new</span> <span class="n">Sum</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">(),</span>
                                  <span class="s">"input_a"</span> <span class="p">)</span> <span class="p">);</span>
   <span class="n">map</span><span class="p">.</span><span class="n">link</span><span class="p">(</span> <span class="k">new</span> <span class="n">Generate</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">(),</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">linked_kernels</span><span class="p">.</span><span class="n">dst</span> <span class="p">),</span> <span class="s">"input_b"</span> <span class="p">);</span>
   <span class="n">map</span><span class="p">.</span><span class="n">link</span><span class="p">(</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">linked_kernels</span><span class="p">.</span><span class="n">dst</span> <span class="p">),</span> <span class="k">new</span> <span class="n">Print</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
   <span class="n">map</span><span class="p">.</span><span class="n">exe</span><span class="p">();</span>
   <span class="k">return</span><span class="p">(</span> <span class="n">EXIT_SUCCESS</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>Using the <em>link()</em> function we can link together compatible combinations of two compute kernels.  Compatible
ports will have the same type or will be able to be cast to the same type. The <em>link()</em> function returns a
reference to the functions that are passed as parameters.  This is a convenience so that the programmer can
instantiate them via the function param with <em>new</em> and use the return values for follow-on <em>link()</em> calls.  This
function has various forms as follows:</p>

<div class="highlight highlight-c++"><pre><span class="cm">/**</span>
<span class="cm"> * version 1: Kernel's a &amp; b are assumed to have a single output</span>
<span class="cm"> * and input port respectively, otherwise an exception is thrown.   </span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">::</span><span class="n">spec</span> <span class="n">t</span> <span class="o">=</span> <span class="n">order</span><span class="o">::</span><span class="n">in</span> <span class="o">&gt;</span>
      <span class="kt">kernel_pair_t</span> <span class="n">link</span><span class="p">(</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">b</span> <span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * version 2: Kernel a has multiple output ports, but one named _a\_port_, Kernel</span>
<span class="cm"> * b has a single input port otherwise an exception is thrown.</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">::</span><span class="n">spec</span> <span class="n">t</span> <span class="o">=</span> <span class="n">order</span><span class="o">::</span><span class="n">in</span> <span class="o">&gt;</span> 
      <span class="kt">kernel_pair_t</span> <span class="n">link</span><span class="p">(</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span>  <span class="n">a_port</span><span class="p">,</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">b</span> <span class="p">);</span>
<span class="cm">/** </span>
<span class="cm"> * version 3: Kernel a has a single output port (otherwise an exception is thrown,</span>
<span class="cm"> * Kernel b has multiple input ports with at least one named _b\_port_</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">::</span><span class="n">spec</span> <span class="n">t</span> <span class="o">=</span> <span class="n">order</span><span class="o">::</span><span class="n">in</span> <span class="o">&gt;</span>
      <span class="kt">kernel_pair_t</span> <span class="n">link</span><span class="p">(</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b_port</span> <span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * version 4: both kernels have multiple output ports with at least one named _a\_port_ </span>
<span class="cm"> * and _b\_port_, otherwise an exception is thrown.</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">::</span><span class="n">spec</span> <span class="n">t</span> <span class="o">=</span> <span class="n">order</span><span class="o">::</span><span class="n">in</span> <span class="o">&gt;</span>
      <span class="kt">kernel_pair_t</span> <span class="n">link</span><span class="p">(</span> <span class="n">Kernel</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a_port</span><span class="p">,</span> 
                          <span class="n">Kernel</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b_port</span> <span class="p">);</span>
</pre></div>

<p>
  Calling link has the effect of connecting Kernel *a to Kernel *b through the 
  specified port (or the only port if none is specified).  This creates a data 
  flow graph of kernels and “streams” through which data passes.  Type checking 
  is also done at this time between ports.  Types are considered compatible if they
  are the same or cast-able.  If types are cast-able then the smallest (narrowest) 
  type of the two is chosen for the port allocation.  The types are cast transparently 
  to the user.  At this point nothing has yet been allocated.  When the <em>exe()</em> 
  function of Map is called, everything is put into motion.  The data flow graph stored
  within Map is analyzed for “unconnected” edges, which could indicate compute kernels 
  which have connected incorrectly, this is in addition to the type checking already 
  performed.  Each compute kernel is “mapped” to a thread or process for execution, 
  the appropriate type of link is automatically allocated by the run-time, finally 
  the scheduler begins executing the data flow graph.  In the final version two threads
  monitor the execution schedule and stream status ensuring streams are properly allocated.  
  Future versions will automatically increase or decrease the parallelism within the data-flow 
  graph (dev version will get this first).  
</p>
      </section>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-55176313-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
