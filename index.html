<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Raft Light by jonathan-beard</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Raft Light</h1>
        <h2>Simple, easy to use stream computation library for C++.</h2>

        <section id="downloads">
          <a href="https://github.com/jonathan-beard/RaftLight/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/jonathan-beard/RaftLight/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/jonathan-beard/RaftLight" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a name="welcome-to-the-raft-light-c-template-library" class="anchor" href="#welcome-to-the-raft-light-c-template-library"><span class="octicon octicon-link"></span></a>Welcome to the Raft Light C++ template library</h3>

<p>To checkout the library do the following:</p>

<pre><code>$ cd location_for_the_repo
$ git clone git@github.com:jonathan-beard/RaftLight.git
$ cd RaftLight
$ git clone git@github.com:jonathan-beard/templatedLockFreeFIFOQueue.git -b dev fifo
</code></pre>

<p>Now you have all the files needed.  At the moment the system is in the beta phase, really designed
for research and hobby usage.  Eventually it'll have a proper build system.  At the moment 
however you'll have to do the following:</p>

<pre><code>$ cd location_for_the_repo
$ make
</code></pre>

<p>This will generate the static library file <em>raftlight.a</em>.  Once this is built you're basically
set save for a few details, which will be laid out within the tutorial as we build a simple
example.</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Designer Templates</h3>

<p>We've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.</p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>In 2013 Jonathan Beard (<a href="https://github.com/jonathan-beard" class="user-mention">@jonathan-beard</a>) started work on the Raft language.  In the interim,
and realizing the ubiquity of the C++ language, he started work on a template library that 
uses the same framework as the full Raft language and run-time system.  This C++ library is 
the result.</p>

<h3>
<a name="genealogy" class="anchor" href="#genealogy"><span class="octicon octicon-link"></span></a>Genealogy</h3>

<p>There have been several dozen streaming languages.  Most notable of which is probably StreaMIT.  I've worked on the Auto-Pipe streaming runtime system (both versions 1 and 2) developed at Washington University.  This particular streaming library was developed as a faster way to get started with stream processing by enabling users to stick to a language with which they are already familiar (C++).</p>

<h3>
<a name="tutorial" class="anchor" href="#tutorial"><span class="octicon octicon-link"></span></a>Tutorial</h3>

<p>The tutorial could be written two ways.  The first would be to enumerate all the possible functions and configurations.  The second would be to give an example and explain the example as it is presented.  We'll start with the example approach then move to a short directory of useful functions followed by some permutations on the previously mentioned example.</p>

<p>First and foremost what is stream processing.  Essentially it is a compute paradigm that envisions perfectly safe, threaded programs (although we'll relax this a bit with locked shared objects, shown much later in the tutorial).  Stream programs themselves are decomposed into compute "kernels" which are connected by communications links called "streams."  As an extremely simple example, take a look at the figure below which has three compute "kernels" (A,B,C) connected by two "streams."</p>

<p><img src="http://www.cse.wustl.edu/%7Ebeardj/queues.eps" alt="tandem queue"></p>

<p>As a concrete example we have a "sum" application which generates a random stream of numbers from two separate threads, sums them in another and finally prints them in yet another thread.  Admittedly this is a bit wasteful in practice, however its a nice dirt simple example. </p>

<pre><code>
</code></pre>
      </section>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-55176313-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>